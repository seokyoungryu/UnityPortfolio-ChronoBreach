# ğŸ® Unity3D Portfolio RPG Game - Chrono Breach


## ğŸ“š ëª©ì°¨
- [UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨](#-uml-í´ë˜ìŠ¤-ë‹¤ì´ì–´ê·¸ë¨)
- [ë™ì˜ìƒ ë§í¬](#-ë™ì˜ìƒ-ë§í¬)
- [ì •ë³´](#-ì •ë³´)
- [í•µì‹¬ ê¸°ìˆ  íŒŒíŠ¸](#-í•µì‹¬-ê¸°ìˆ -íŒŒíŠ¸)
  - [Dungeon System](#-dungeon-system)
  - [Dash System](#-dash-system)
- [íŠ¸ëŸ¬ë¸” ìŠˆíŒ…](#-íŠ¸ëŸ¬ë¸”-ìŠˆíŒ…)
  - [ë©”í…Œë¦¬ì–¼ ìµœì í™” ê³¼ì •](#-ë©”í…Œë¦¬ì–¼-ìµœì í™”-ê³¼ì •)
  - [Layout group ì„±ëŠ¥ ë¬¸ì œ](#-Layout-group-ì„±ëŠ¥-ë¬¸ì œ)
  - [UI ìŠ¤í¬ë¡¤ ë¬¸ì œ](#-UI-ìŠ¤í¬ë¡¤-ë¬¸ì œ)
    
# âš™ï¸ UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨
í”„ë¡œì íŠ¸ì˜ ì£¼ìš” ì‹œìŠ¤í…œ êµ¬ì¡°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” UML ë‹¤ì´ì–´ê·¸ë¨ì…ë‹ˆë‹¤.
<img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UML_F4.drawio.png" alt="UML Diagram" width="1000" />



 ### [ğŸ§© **UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ì—´ê¸°**](https://app.diagrams.net/?url=https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/refs/heads/main/UML_F4.drawio) (ctrl + wheelë¡œ ì¤Œ ì•„ì›ƒ)

# ğŸ“¹ ë™ì˜ìƒ ë§í¬
**ë™ì˜ìƒ í™”ì§ˆì„ 4kë¡œ ì„ íƒí•˜ì—¬ ì‹œì²­í•´ì£¼ì‹œë©´ ê°ì‚¬í•©ë‹ˆë‹¤.** 
<a href="https://www.youtube.com/watch?v=sTdEx9n8rMI" target="_blank">
  <img src="https://img.youtube.com/vi/sTdEx9n8rMI/maxresdefault.jpg" alt="Unity Portfolio (4K)" style="width:100%;">
</a>

### [ğŸ¬ **ìœ íŠœë¸Œ ì˜ìƒ ë°”ë¡œ ë³´ê¸°**](https://www.youtube.com/watch?v=sTdEx9n8rMI)


---

# ğŸ› ï¸ ì •ë³´

- **Unity Version**: 2021.3.17f1
- **ì œì‘ ê¸°ê°„**: 1ë…„ 2ê°œì›”
- **ê²Œì„ ì¥ë¥´**: 3D Action RPG
- **íƒ€ê²Ÿ í”Œë ›í¼**: PC
- **ì´ë©”ì¼**: whtkrl@gmail.com
- **ì œì‘ì¸ì›**: 1ëª…
---

# â³ í•µì‹¬ ê¸°ìˆ  íŒŒíŠ¸
<br><br>

## ğŸ“Œ Dungeon System
**ëª¨ë“ˆí˜• í™•ì¥ êµ¬ì¡°ì˜ ìœ ì—°í•œ ë˜ì „ UML**ğŸ¯
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UML_D1.png" width="650"/> </p>
<br><br>

## ğŸ¯ ì„¤ê³„ ëª©ì 
ì´ˆê¸°ì—ëŠ” ë‹¨ìˆœíˆ ëª¨ë“  ì  ì²˜ì¹˜ ì‹œ í´ë¦¬ì–´ë˜ëŠ” êµ¬ì¡°ë§Œ êµ¬í˜„í•˜ë ¤ í–ˆìœ¼ë‚˜, ë˜ì „ë³„ë¡œ ê³ ìœ í•œ ëª©í‘œì™€ ê·œì¹™ì„ ì œê³µí•˜ë©´ ê²Œì„ í”Œë ˆì´ì˜ ê¹Šì´ì™€ ë‹¤ì–‘ì„±ì´ í¬ê²Œ í–¥ìƒëœë‹¤ê³  íŒë‹¨í•˜ì—¬ í˜„ì¬ì˜ ëª¨ë“ˆí˜•Â·í™•ì¥í˜• êµ¬ì¡°ë¡œ ë°œì „ì‹œì¼°ìŠµë‹ˆë‹¤.  

ì„¤ê³„ ê³¼ì •ì—ì„œëŠ” ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ íŠ¹íˆ ì¤‘ì ì ìœ¼ë¡œ ê³ ë ¤í–ˆìŠµë‹ˆë‹¤.  

- **ìœ ì§€ë³´ìˆ˜ì„±**: ë˜ì „ë³„ ë¡œì§ ë¶„ë¦¬ ë° ë…ë¦½ ê´€ë¦¬  
- **í™•ì¥ì„±**: ë°ì´í„°ë§Œ êµì²´í•´ ë‹¤ì–‘í•œ ë˜ì „ ìœ í˜• ì¶”ê°€ ê°€ëŠ¥  

---

<br><br>

## ğŸ¯ Dungeon êµ¬ì„± ìš”ì†Œ 
ì•„ë˜ êµ¬ì„±ë“¤ì€ ë˜ì „ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë°ì´í„°ë¥¼ ê°„ê²°í•˜ê²Œ í‘œí˜„í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.  

<br><br>

## Title
- ë˜ì „ì˜ ì´ë¦„, ìœ í˜•, ì„¤ëª… ë“±  
- ë˜ì „ì„ ì‹ë³„í•˜ê³  UI ë° ì‹œìŠ¤í…œì—ì„œ í™œìš©ë˜ëŠ” ê¸°ë³¸ ì •ë³´  
- **( Normal, Rush, Protect, Rescuer, Target )**
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Title.png" width="650"/> </p>

  <br><br>
  
## Category
- ì‚¬ìš©í•˜ëŠ” Controller ì„¤ì •.
```csharp
[CreateAssetMenu(menuName ="Map/Dungeon Category/Normal ", fileName ="NormalDungeonCategory")]
public class NormalDungeonCategory : BaseDungeonCateogry
{
    public override PlayerStateController InitControllerSetting(BaseDungeonTitle title)
    {
        PlayerStateController originController = title.OriginController;
        originController.allowStates.Clear();
        originController.allowStates.Add(originController.GetState<MoveState>());
        originController.allowStates.Add(originController.GetState<AttackState>());
        originController.allowStates.Add(originController.GetState<RollState>());
        originController.allowStates.Add(originController.GetState<SkillState>());
        originController.allowStates.Add(originController.GetState<DamagedState>());
        originController.allowStates.Add(originController.GetState<CounterAttackState>());
        originController.allowStates.Add(originController.GetState<DeadState>());
        originController.allowStates.Add(originController.GetState<DashState>());
        return originController;
    }
}
```
- Normal Categoryì—ì„œëŠ” í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ Stateë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.

<br><br>

## Condition
- ë˜ì „ì— ì…ì¥í•˜ê¸° ìœ„í•œ ì¡°ê±´ì„ ëª…ì‹œ  
  - í”Œë ˆì´ì–´ ë ˆë²¨  
  - í•„ìš” ì•„ì´í…œ  
  - íŠ¹ì • ìŠ¤í…Œì´ì§€ ì„ í–‰ ì—¬ë¶€  

<br><br>

## Function
- ë˜ì „ ì§„í–‰ ì „ì²´ë¥¼ ë‹´ë‹¹í•˜ëŠ” í•µì‹¬ í”„ë¡œì„¸ìŠ¤  
  - ë¼ìš´ë“œ ì‹œì‘  
  - ëª¬ìŠ¤í„°/ë³´ìŠ¤ ìŠ¤í°  
  - í´ë¦¬ì–´ ì¡°ê±´ ì²´í¬  
  - ì¢…ë£Œ ë° ë³´ìƒ ì²˜ë¦¬  

```csharp
[CreateAssetMenu(menuName = "Map/Dungeon Function/Normal Function ", fileName = "NormalFunction")]
public class NormalDungeonFunction : BaseDungeonFunction<NormalDungeonTitle>
{
    public override void ExcuteProcess(NormalDungeonTitle title)
    {
        SoundManager.Instance.PlayBGM_CrossFade(title.BaseBGM, 4f);
        title.SpawnData.dungeon = title.dungeonCoroutine;
        title.DungeonMapData.ExcuteTeleportMap();

        title.SpawnData.onExcuteBoss += () => { SoundManager.Instance.PlayBGM_CrossFade(title.BossBGM, 3f); };
        ScenesManager.Instance.OnExcuteAfterLoading = () => title.DungeonMapData.ExcuteTeleportController(title.ExcuteController, title.DungeonSpawnPosition);
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.SettingSpawnPositionList(title.DungeonSpawnPosition);
        ScenesManager.Instance.OnExcuteAfterLoading += () => GameManager.Instance.Cam.SetTarget(title.ExcuteController.gameObject);
        ScenesManager.Instance.OnExcuteAfterLoading += () => GameManager.Instance.Cam.ResetRotation();
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.StartWave();
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.CreateExistBarrier();
        ScenesManager.Instance.OnExcuteAfterLoading += () => CommonUIManager.Instance.ExcuteGlobalNotifer(title.InitGlobalNotifier);

        title.SpawnData.onCompleteDungeon += () => QuestManager.Instance.ReceiveReport(QuestCategoryDefines.COMPLETE_DUNGEON, title.TaskTarget, 1);
        GameManager.Instance.Player.playerStats.OnDead_ += () => title?.SpawnData?.ExcuteFailProcess();
    }
}

```
<br><br>

## Reward
- í´ë¦¬ì–´ ë³´ìƒ ì •ë³´  
  - ê²½í—˜ì¹˜
  - ëª…ì„±ì¹˜
  - ìŠ¤í‚¬í¬ì¸íŠ¸
  - ì•„ì´í…œ  
  - ê³¨ë“œ  
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/R1.png" width="700" style="display:inline-block;"/>

  <br><br>
  
## MapData
- ë˜ì „ì— ì‚¬ìš©ë˜ëŠ” ë˜ì „ Scene indexì™€ ìœ„ì¹˜, íšŒì „ ë“±ì˜ ë§µ ì •ë³´.

<br><br>

## SpawnPosition
- ë˜ì „ ë‚´ ìœ„ì¹˜ ì •ë³´ êµ¬ì„± ìš”ì†Œ  
  - í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜  
  - Enemy/Boss ìŠ¤í° ì§€ì   
  - íŠ¸ë¦¬ê±° ì´ë²¤íŠ¸ ìœ„ì¹˜  

  <p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜1.png" width="700" style="display:inline-block;"/>
-OnValidate() í•©ìˆ˜ë¡œ ë°‘ì—ìˆëŠ” Map Position Prefabì˜ ì •ë³´ë¥¼ ìë™ ì„¸íŒ…í•©ë‹ˆë‹¤.

<div align="center">
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜2.png" width="300" style="display:inline-block;"/>
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜3.png" width="300" style="display:inline-block;"/>
</div>
- OnDrawGizmos() í•¨ìˆ˜ë¡œ Root Transformì˜ child Transformì˜ ìœ„ì¹˜ë“¤ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ë©° positions ë¦¬ìŠ¤íŠ¸ì— ìë™ ì¶”ê°€í•©ë‹ˆë‹¤.

<br><br>

## SpawnData 
- ì „íˆ¬ êµ¬ì„±ì— í•„ìš”í•œ ëª¨ë“  ìŠ¤í° ë° ë¼ìš´ë“œ ë°ì´í„°  
  - Enemy/Boss ìŠ¤í° ë¦¬ìŠ¤íŠ¸
  - Playable AI ë¦¬ìŠ¤íŠ¸
  - ì´ë™ ë¶ˆê°€ ë²½ ì •ë³´
  - ì›¨ì´ë¸Œ/ë¼ìš´ë“œ êµ¬ì„±   
- **( Normal, Rush, Protect, Rescuer, Target, TimeAttackRush )**
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/SpawnD1.png" width="650"/> </p>


<br><br><br><br>

## âš¡ Dash System
<p align="center">  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Dash.gif" width="400" style="display:inline-block;"/>
 
- ê³ ì† íƒ€ê²© ê¸°ë°˜ì˜ ì§€í˜•Â·ì  ê°ì§€í˜• ëŒ€ì‹œ ì‹œìŠ¤í…œ 

ëŒ€ì‹œ ì‹œìŠ¤í…œì€ ë‹¨ìˆœí•œ ëŒì§„ì´ ì•„ë‹ˆë¼ ì§€í˜•, ì , ì¥ì• ë¬¼, ì¹´ë©”ë¼, ì¿¨íƒ€ì„ UIë¡œ êµ¬ì„±ëœ ì „íˆ¬ ì‹œìŠ¤í…œìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì•„ë˜ ë‘ ê°€ì§€ ëª©í‘œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤.
- **ì •í™•ì„± : ì•ˆì „í•˜ê²Œ ì´ë™ ê°€ëŠ¥í•œ ì§€ì ë§Œ ê³„ì‚°í•˜ì—¬ ì˜¤ë™ì‘ì„ ìµœì†Œí™”**
- **ì „ìˆ ì„± : ì Â·ì§€ë©´Â·ì¥ì• ë¬¼ íŒì •ì„ ì¡°í•©í•´ ì „ëµì ìœ¼ë¡œ ëŒ€ì‹œë¥¼ í™œìš© ê°€ëŠ¥**
  
<br><br>

## â­ Dash ì„¤ê³„ í•µì‹¬ ìš”ì†Œ
<div align="center">
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/G1.gif" width="450" style="display:inline-block;"/>
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/G2.gif" width="450" style="display:inline-block;"/>
</div>

- ëŒ€ì‹œëŠ” ì•„ë˜ì™€ ê°™ì€ êµ¬ì¡°ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.
  
<br><br>
## Target Detect
- ëŒ€ìƒ ìœ„ì¹˜ ê³„ì‚°
  - BaseController ì—¬ë¶€ì— ë”°ë¼ í”¼ê²© ì¤‘ì‹¬ì  ë˜ëŠ” Transform ìœ„ì¹˜ë¥¼ íƒ€ê¹ƒ ì¢Œí‘œë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ì§€ë©´ ê²€ì¶œ ì‹œ ëŒ€ì‹œ ë¶ˆê°€
  - CheckDetectGround(targetDir, distance) ì—ì„œ ì§€ë©´ì´ ê°ì§€ë˜ë©´ í•´ë‹¹ ìœ„ì¹˜ëŠ” ëŒ€ì‹œ ëŒ€ìƒì—ì„œ ì œì™¸ë©ë‹ˆë‹¤.
- ì¥ì• ë¬¼ ê²€ì¶œ ì‹œ ëŒ€ì‹œ ë¶ˆê°€
  - CheckDetectObstacle(targetDir, distance) ê²°ê³¼ ì¥ì• ë¬¼ì´ ì°¨ë‹¨í•˜ê³  ìˆìœ¼ë©´ ëŒ€ì‹œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
- ê·¼ê±°ë¦¬ ëŒ€ìƒ ì •ë°€ ì²´í¬
  - íƒ€ê¹ƒì´ targetingAllowDistance ì´ë‚´ë¼ë©´, ë” ì¢ì€ ì¤‘ì•™ ìŠ¤í¬ë¦° ì˜ì—­(targetingLimitScreenPoint) ì•ˆì— ìˆì„ ë•Œë§Œ ëŒ€ì‹œë¥¼ í—ˆìš©í•©ë‹ˆë‹¤.
- ì¼ë°˜ íƒ€ê¹ƒíŒ… ì˜ì—­ ì²´í¬
  - ê·¼ê±°ë¦¬ ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ëª»í•˜ë”ë¼ë„, ë„“ì€ ê¸°ì¤€ ìŠ¤í¬ë¦° ì˜ì—­(limitDistance) ì•ˆì— ìœ„ì¹˜í•˜ë©´ ëŒ€ì‹œ ê°€ëŠ¥ ëŒ€ìƒìœ¼ë¡œ ì¸ì •í•©ë‹ˆë‹¤.
- ë‘ ì¡°ê±´ ëª¨ë‘ ë²—ì–´ë‚˜ë©´ ëŒ€ì‹œ ë¶ˆê°€
  - ìŠ¤í¬ë¦° ê¸°ì¤€ì ì„ ë²—ì–´ë‚˜ê±°ë‚˜ ê±°ë¦¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•  ê²½ìš° ëŒ€ì‹œëŠ” í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
```csharp
  private bool CheckCanDashTarget(Transform targetTr)
    {
        BaseController targetCon = targetTr.GetComponent<BaseController>();
        Vector3 targetPos = targetCon != null ? targetCon.damagedPosition.position : targetTr.position;
        Vector2 point = cam.MainCam.WorldToScreenPoint(targetPos);
        targetDir = (targetPos - centerPosition).normalized;
        float distance = (targetPos - (controller.transform.position + (Vector3)centerOffset)).magnitude;

        gizmoObstacleDir = targetDir;
        gizmoObstacleDistance = distance;

        //ë•…ì¼ê²½ìš°
        if (CheckDetectGround(targetDir, distance))
        {
            return false;
        }

        ///íƒ€ê²Ÿ ìœ„ì¹˜ì— ë ˆì´ì–´ ì´ì„œ ì¥ì• ë¬¼ ìˆë‚˜ íŒë‹¨.
        if (CheckDetectObstacle(targetDir, distance))
        {
            return false;
        }

        //íƒ€ê²ŸíŒ…ì¼ ê²½ìš° 
        if (distance <= targetingAllowDistance)
        {
            if (centerScreenPoint.x + targetingLimitScreenPoint.x >= point.x && centerScreenPoint.x - targetingLimitScreenPoint.x <= point.x &&
            centerScreenPoint.y + targetingLimitScreenPoint.y >= point.y && centerScreenPoint.y - targetingLimitScreenPoint.y <= point.y)
                return true;
        }

        if (centerScreenPoint.x + limitDistance.x >= point.x && centerScreenPoint.x - limitDistance.x <= point.x &&
            centerScreenPoint.y + limitDistance.y >= point.y && centerScreenPoint.y - limitDistance.y <= point.y)
        {
            return true;
        }

        return false;
    }

```
<br><br>
## Ground Check
- ëŒ€ì‹œ ê°€ëŠ¥í•œ ì§€ì ì„ ì°¾ê¸° ìœ„í•´ ëª©í‘œì ê¹Œì§€ì˜ ìˆ˜í‰ ì´ë™ ê±°ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¼ì • ê°„ê²©ìœ¼ë¡œ ì§€ë©´ì„ ìƒ˜í”Œë§í•©ë‹ˆë‹¤.
- ì‘ë™ ë°©ì‹
  - í”Œë ˆì´ì–´ â†’ íƒ€ê¹ƒ ë°©í–¥ìœ¼ë¡œ ì¼ì • Intervalë§Œí¼ ì „ì§„
  - ê° ì‹œì ì—ì„œ ì•„ë˜ë¡œ SphereCast
  - ì ì´ ìˆëŠ” ìœ„ì¹˜ë©´ Skip
  - ìµœì´ˆë¡œ ì•ˆì „í•œ ì§€ë©´ì„ ì°¾ìœ¼ë©´ ê·¸ ìœ„ì¹˜ë¡œ ì´ë™ í™•ì •

ğŸ”‘ í•µì‹¬ ì½”ë“œ
```csharp
private bool CheckCanDashGround()
{
    sumInterval = 0f;
    targetDirFromDashPos = (dashTargetTr.position - tmpDashPosition);
    groundDistance = targetDirFromDashPos.magnitude;
    groundSumCount = (int)((groundDistance - minDetectTargetDistance) / groundDetectInterval);
    currentTargetHeight = (dashTargetTr.position - controller.transform.position).y;

    if (currentTargetHeight < minDetectHeight || currentTargetHeight > maxDetectHeight)
        return false;

    targetDirFromDashPos.y = 0f;
    targetDirFromDashPos.Normalize();

    for (int i = 0; i < groundSumCount; i++)
    {
        startPos = tmpDashPosition + targetDirFromDashPos * sumInterval + Vector3.up * groundStartYOffset;
        sumInterval += groundDetectInterval;

        if (DetectEnemy(startPos))
            continue;

        if (Physics.SphereCast(startPos, groundDetectRadius, -Vector3.up,out groundCheckRayHit, groundYRange, groundLayer))
        {
            canDashPosition = groundCheckRayHit.point;
            return true;
        }
        else
            canDashPosition = Vector3.zero;
    }
    return false;
}
```
<br><br>

## Enemy Detection
- ëŒ€ì‹œ ê²½ë¡œì— ì ì´ ìˆëŠ”ì§€ ê²€ì‚¬í•´ ì¶©ëŒ ê°ì§€ ì‹œ Skip ë˜ëŠ” Hit ì²˜ë¦¬í•©ë‹ˆë‹¤.

ğŸ”‘ í•µì‹¬ ì½”ë“œ
```csharp
private bool DetectEnemy(Vector3 startPosition)
{
    RaycastHit groundHit;

    // 1) ì§€ë©´ì´ ì—†ëŠ” ê²½ìš° - ì•ˆì „
    if (!Physics.Raycast(startPosition, -Vector3.up, out groundHit, groundYRange, groundLayer))
        return true;

    // 2) ì§€ë©´ê¹Œì§€ SphereCast ì‹œ ì  ê°ì§€
    if (Physics.SphereCast(startPosition, groundDetectRadius, -Vector3.up,
        out groundCheckRayHit, groundHit.point.y, enemyLayer))
    {
        drawEnemyHitPoints.Add(groundCheckRayHit.point);
        return true;
    }

    // 3) ì‹œì‘ ì§€ì ì— ì ì´ ìˆëŠ”ì§€ ê²€ì‚¬
    if (Physics.OverlapSphereNonAlloc(startPosition, groundDetectRadius,
        groundEnemyColls, enemyLayer) > 0)
    {
        drawEnemyHitPoints.Add(startPosition);
        return true;
    }

    return false;
}
```

<br><br>

## Obstacle Check
<p align="center">  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Ground.gif" width="400" style="display:inline-block;"/>
 
- ëŒ€ì‹œ ê²½ë¡œì— ì¥ì• ë¬¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ ì‚¬ì „ ê²€ì¶œí•©ë‹ˆë‹¤.
  - OverlapSphereNonAlloc ê¸°ë°˜ ì¶©ëŒ ì˜ˆì¸¡ ë° ìµœì í™”
- ì¥ì• ë¬¼ê³¼ ì¶©ëŒí•˜ë©´ Target ìë™ ë³€ê²½ ë˜ëŠ” ëŒ€ì‹œ ì·¨ì†Œ
  
<br><br>
## Dash Movement + Camera + UI
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UI1.gif" width="400" style="display:inline-block;"/>

- íƒ€ê¹ƒ UIë¡œ í˜„ì¬ ì„ íƒëœ ëŒ€ìƒ ì‹œê°í™” 
- ëŒ€ì‹œ ì´ë™ì´ í—ˆìš©ë˜ë©´ ë‹¤ìŒ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.
  - ì¹´ë©”ë¼ FOV ë³€í™”
  - ì›ê±°ë¦¬/ê·¼ê±°ë¦¬ ëŒ€ì‹œë³„ SmoothSpeed ìë™ ì¡°ì ˆ
  - ì„±ê³µ ì¹´ìš´íŠ¸ UI ì—…ë°ì´íŠ¸
  - ëŒ€ì‹œ ìŠ¤íƒ ê¸°ë°˜ ì¿¨íƒ€ì„ íšŒë³µ

```csharp
 private IEnumerator DashMoveProcess_Co()
    {
        if (dashTargetTr == null)
            yield break;
        float endTime = dashClip.EndTime;

        if (CanTeleportToTarget(dashTargetTr))
        {
            StartCoroutine(DashCameraProcess_Co(false));
            yield return new WaitForSeconds(farDelayFOVMoveTime);
            controller.RotateToTarget(dashTargetTr.position);
            controller.myAnimator.CrossFade(dashClip.AnimationName, 0.1f);
            controller.TranslatePosition(canDashPosition);
            controller.StartCoroutine(DashDamageProcess_Co());
        }
        else
        {
            StartCoroutine(DashCameraProcess_Co(true));
            yield return new WaitForSeconds(nearDelayFOVMoveTime);
            controller.RotateToTarget(dashTargetTr.position);
            controller.myAnimator.CrossFade(dashClip.AnimationName, 0.1f);
            controller.StartCoroutine(DashDamageProcess_Co());
        }

        yield return new WaitForSeconds(dashClip.EndTime);
        doneDashState = true;
        dashTargetTr = null;
    }
 

```



<br><br><br><br>


# â³ íŠ¸ëŸ¬ë¸” ìŠˆíŒ…
<br><br><br>

## ğŸ¨ ë©”í…Œë¦¬ì–¼ ìµœì í™” ê³¼ì •
- NPCë‚˜ ëª¬ìŠ¤í„°ë¥¼ ìƒì„±í•  ë•Œ, ìºë¦­í„°ë³„ë¡œ ì§€ì •ëœ ìƒ‰ìƒì„ ì ìš©í•˜ê¸° ìœ„í•´ ë©”í…Œë¦¬ì–¼ ì»¬ëŸ¬ ê°’ì„ ë³€ê²½í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.
- ì¦‰, ìŠ¤í°ëœ ìºë¦­í„°ë§ˆë‹¤ ê³ ìœ í•œ ìƒ‰ìƒì„ ì„¤ì •í•˜ëŠ” ê³¼ì •ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ë©”í…Œë¦¬ì–¼ì„ ìˆ˜ì •í•˜ëŠ” ë¡œì§ì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤.


<br><br>

## âš  ë¬¸ì œ ë°œìƒ
- ë©”í…Œë¦¬ì–¼ì˜ ìƒ‰ìƒì„ ë³€ê²½í•˜ëŠ” ê³¼ì •ì—ì„œ ê¸°ì¡´ ë©”í…Œë¦¬ì–¼ì„ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, Unityê°€ ë‚´ë¶€ì ìœ¼ë¡œ ìƒˆë¡œìš´ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ë³€ê²½ì„ ì ìš©í•˜ê³  ìˆë‹¤ëŠ” ì‚¬ì‹¤ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.

ì¦‰, **ê³µìœ  ë©”í…Œë¦¬ì–¼(Shared Material)** ì„ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, Rendererë§ˆë‹¤ **ê³ ìœ í•œ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤(Material Instance)** ë¥¼ ìƒˆë¡œ ìƒì„±í•´ ì ìš©í•˜ëŠ” êµ¬ì¡°ì˜€ìŠµë‹ˆë‹¤.

- ì´ë¡œ ì¸í•´ NPCë‚˜ ëª¬ìŠ¤í„°ê°€ ë§ì•„ì§ˆìˆ˜ë¡ ê³ ìœ  ì¸ìŠ¤í„´ìŠ¤ê°€ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ëŠ˜ì–´ë‚¬ê³ , ê·¸ë§Œí¼ ë“œë¡œìš°ì½œ ì¦ê°€ â†’ ë°°ì¹­ì´ ê¹¨ì§ â†’ í¼í¬ë¨¼ìŠ¤ ì €í•˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.


<br><br>


## ğŸ” ì›ì¸ ë¶„ì„
- Unityì˜ ë©”í…Œë¦¬ì–¼ êµ¬ì¡°ìƒ renderer.materialì„ ìˆ˜ì •í•˜ë©´ ê¸°ì¡´ ë©”í…Œë¦¬ì–¼ì€ ê³µìœ ëœ ìƒíƒœ

ìˆ˜ì • ìˆœê°„ Rendererë§ˆë‹¤ ê³ ìœ í•œ ì¸ìŠ¤í„´ìŠ¤(Material Instance)ë¥¼ ìƒì„±
í•˜ê²Œ ë©ë‹ˆë‹¤.

ì¦‰, ìƒ‰ìƒ í•˜ë‚˜ë§Œ ë°”ë€Œì–´ë„ ì „ë¶€ ë‹¤ë¥¸ ë©”í…Œë¦¬ì–¼ë¡œ ì¸ì‹ë˜ê¸° ë•Œë¬¸ì—
Static/Dynamic Batchingì´ ì ìš©ë˜ì§€ ì•Šê³  Draw Callì´ ë¶ˆí•„ìš”í•˜ê²Œ í™•ëŒ€ë˜ëŠ” ê²ƒì´ ì›ì¸ì´ì—ˆìŠµë‹ˆë‹¤.


<br><br>

## âœ… í•´ê²° ë°©ë²• 

- ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **Material Property Block** ë°©ì‹ì„ ì ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.
- Material Property BlockëŠ” ê¸°ì¡´ ê³µìœ  ë©”í…Œë¦¬ì–¼ì„ ìœ ì§€í•œ ì±„, Rendererë³„ ìƒ‰ìƒÂ·íŒŒë¼ë¯¸í„°ë§Œ ê°œë³„ì ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

ì´ë¡œì¸í•´ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•Šê³ , ë“œë¡œìš°ì½œì„ ì¦ê°€ì‹œí‚¤ì§€ ì•Šìœ¼ë©°, ì»¤ìŠ¤í„°ë§ˆì´ì§• ìƒ‰ìƒ ì ìš©ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

```csharp
 public void SetMaterialsColor(Renderer renderer)
    {
        MaterialPropertyBlock propertyBlock = new MaterialPropertyBlock();

        propertyBlock.SetColor("_Color_Primary", Color_Primary);
        propertyBlock.SetColor("_Color_Secondary", Color_Secondary);
        propertyBlock.SetColor("_Color_Leather_Primary", Color_Leather_Primary);
        propertyBlock.SetColor("_Color_Metal_Primary", Color_Metal_Primary);
        propertyBlock.SetColor("_Color_Leather_Secondary", Color_Leather_Secondary);
        propertyBlock.SetColor("_Color_Metal_Dark", Color_Metal_Dark);
        propertyBlock.SetColor("_Color_Metal_Secondary", Color_MertalSecondary);
        propertyBlock.SetColor("_Color_Hair", Color_Hair);
        propertyBlock.SetColor("_Color_Skin", Color_Skin);
        propertyBlock.SetColor("_Color_Stubble", Color_Stubble);
        propertyBlock.SetColor("_Color_Scar", Color_Scar);
        propertyBlock.SetColor("_Color_BodyArt", Color_BodyArt);
        propertyBlock.SetColor("_Color_Eyes", Color_Eyes);

        renderer.SetPropertyBlock(propertyBlock);
    }
```


<br><br><br><br>




## ğŸ¨Layout group ì„±ëŠ¥ ë¬¸ì œ  
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/L1.png" width="500" style="display:inline-block;"/>

- ì´ˆê¸°ì—ëŠ” Inventory, ìƒì  UI, Reward UI ë“± ë‹¤ìˆ˜ì˜ UI ìš”ì†Œê°€ í‘œì‹œë˜ëŠ” í™”ë©´ì— Unityê°€ ê¸°ë³¸ ì œê³µí•˜ëŠ” Layout Groupì„ ì‚¬ìš©í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.
  ë ˆì´ì•„ì›ƒ ì •ë ¬ì´ ìë™ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ UI êµ¬ì„±ì€ í¸ë¦¬í–ˆì§€ë§Œ, ì‹¤ì œ í”Œë ˆì´ í™˜ê²½ì—ì„œëŠ” ì˜ˆìƒì¹˜ ëª»í•œ ì„±ëŠ¥ ì €í•˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. 



<br><br>


## âš  ë¬¸ì œ ë°œê²¬

- UI ìš”ì†Œê°€ ë§ì•„ì§ˆìˆ˜ë¡ í™”ë©´ ì „í™˜ ë° ìŠ¤í¬ë¡¤ ìƒí™©ì—ì„œ í”„ë ˆì„ ì €í•˜ê°€ ëˆˆì— ë„ê²Œ ì¦ê°€
- Inventoryë‚˜ ìƒì ì²˜ëŸ¼ ìì‹ UIê°€ ë§ì€ íŒ¨ë„ì—ì„œ Canvas Rebuildê°€ ë°˜ë³µì ìœ¼ë¡œ ë°œìƒ
- ì¦‰, ë¶ˆí•„ìš”í•œ ì‘ì—…ì´ ë°œìƒ.



<br><br>

  
## âœ… í•´ê²° ë°©ë²•
- Unity ê¸°ë³¸ Layout Group ì‚¬ìš©ì„ ì¤‘ë‹¨í•˜ê³ , ë ˆì´ì•„ì›ƒì„ í•„ìš”í•  ë•Œë§Œ **ë‹¨ì¼ í˜¸ì¶œ**ë¡œ ê°±ì‹ í•˜ëŠ” êµ¬ì¡°ë¡œ ì¬ì„¤ê³„í•˜ì˜€ìŠµë‹ˆë‹¤.
- UI ë³€ë™ ì—¬ë¶€ì— ë”°ë¼ ì½˜í…ì¸  í¬ê¸°ë¥¼ ìë™ ì¬ì¡°ì •í•  ìˆ˜ ìˆë„ë¡ **Content Size Filter** ê¸°ëŠ¥ì„ ì„ íƒì  ì˜µì…˜ìœ¼ë¡œ ì œê³µí•´ ìœ ì—°í•˜ê²Œ í™œìš©í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.

BaseLayoutGroupì„ ë¶€ëª¨ë¡œ, Grid / Horizontal / Verticalì˜ ê¸°ëŠ¥ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.


<br><br>


**1) AnchorSetting()**
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/L2_1.png" width="500" style="display:inline-block;"/>
  
- ëª¨ë“  RectTransformì˜ ê¸°ì¤€ì ì„ Left-Top ê¸°ì¤€(0,1) ìœ¼ë¡œ ê³ ì •í•˜ì—¬ UI ë°°ì¹˜ ì‹œ í˜¼ë™ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.
- ì¤‘ì‹¬ì , Anchor ì°¨ì´ë¡œ ë°œìƒí•˜ë˜ ì¬ë°°ì¹˜ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê³  ê³„ì‚°ì„ ë‹¨ì¼ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
 protected void AnchorSettings()
    {
        if (uiRect == null)
            uiRect = GetComponent<RectTransform>();
        else if (uiRect != null)
            uiRect.pivot = new Vector2(0, 1);

        foreach (RectTransform rect in childRects)
        {
            rect.anchorMin = new Vector2(0, 1);
            rect.anchorMax = new Vector2(0, 1);
            rect.pivot = new Vector2(0, 1);
        }
    }
```





**1) SortLayout() â€” UI ë°°ì¹˜ ê³„ì‚°ì˜ í•µì‹¬ ë©”ì„œë“œ**
- ì•„ë˜ ë©”ì„œë“œëŠ” UI ìš”ì†Œë¥¼ Row ë˜ëŠ” Column ê¸°ì¤€ìœ¼ë¡œ ë°°ì¹˜í•˜ë©°, íŒ¨ë”©Â·ê°„ê²©Â·ìŠ¬ë¡¯ í¬ê¸° ê³„ì‚° í›„ Anchor ê¸°ì¤€ ìœ„ì¹˜ë¥¼ ì§ì ‘ ì‚°ì¶œí•©ë‹ˆë‹¤.

```csharp
 protected override void SortLayout(List<RectTransform> rectList)
    {
        if (rectList.Count <= 0) 
        {
            uiRect.sizeDelta = new Vector2(0,0);
            return;
        }
        float paddingLR = paddings.left > 0 ? paddings.left : -paddings.right;
        float rectWidth = 0f;
        float rectHeight = 0f + paddings.top;
        int index = 0;

        foreach (RectTransform rect in rectList)
        {
            float paddingBottom = paddings.bottom > 0 ? paddings.bottom : 0;

            if (IsRow())
                RowCalculate(index, ref rectWidth, ref rectHeight, rect);
            else
                ColumeCalculate(index, ref rectWidth, ref rectHeight, rect);

            rect.anchoredPosition = new Vector2(rectWidth + paddingLR, -rectHeight + paddingBottom);
            index++;
        }

        ContentSizeFilter(index, rectWidth, rectHeight);
    }

```




**2) ContentSizeFilter() â€” UI ì½˜í…ì¸  í¬ê¸° ìë™ ì¡°ì • ê¸°ëŠ¥**
- UI í•­ëª©ì´ ë™ì ìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ê²½ìš°, ì „ì²´ ìŠ¬ë¡¯ ì˜ì—­ì´ UI ë‚´ë¶€ì— ìì—°ìŠ¤ëŸ½ê²Œ í™•ì¥ë˜ë„ë¡ Row ë˜ëŠ” Column ê¸°ì¤€ìœ¼ë¡œ RectTransformì˜ sizeDeltaë¥¼ ìë™ ì‚°ì¶œí•©ë‹ˆë‹¤.

```csharp
   private void ContentSizeFilter(int index, float rectWidth, float rectHeight)
    {
        if (useContextSizeFilter && uiRect != null)
        {
            if (IsRow())
            {
                float uiRectWidth = childRects[0].rect.width * RoundToInt(index, row);
                float uiRectHeight = childRects[0].rect.height * (row > index ? index : row);
                uiRect.sizeDelta = new Vector2(rectWidth + childRects[0].rect.width, uiRectHeight);
            }
            else
            {
                float uirectWidth = childRects[0].rect.width * (colume > index ? index : colume);
                float uirectHeight = childRects[0].rect.height * RoundToInt(index, colume);
                uiRect.sizeDelta = new Vector2(uirectWidth, rectHeight + childRects[0].rect.height);
            }
        }
    }

```



## ğŸ¨ UI ìŠ¤í¬ë¡¤ ë¬¸ì œ

- Inventory, ìƒì  Slot, ìŠ¤í‚¬ UI ë“±ì—ì„œëŠ” EventTriggerë¥¼ í™œìš©í•´ ë§ˆìš°ìŠ¤ ì¸í„°ë™ì…˜ì„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤.
- UI ìƒì„± ì‹œ ì•„ë˜ ë©”ì„œë“œë¥¼ í†µí•´ ê° ìš”ì†Œì— í•„ìš”í•œ ì´ë²¤íŠ¸ë¥¼ ë™ì ìœ¼ë¡œ ë“±ë¡í•©ë‹ˆë‹¤.

```csharp
 public static void AddEventTrigger(GameObject go, EventTriggerType type, UnityAction<BaseEventData> action)
    {
        EventTrigger trigger = go.GetComponent<EventTrigger>();
        if (trigger == null)
          trigger = go.AddComponent<EventTrigger>();

        EventTrigger.Entry eventTrigger = new EventTrigger.Entry { eventID = type };
        eventTrigger.callback.AddListener(action);
        trigger.triggers.Add(eventTrigger);
    }
```
í•´ë‹¹ ë°©ì‹ìœ¼ë¡œ ìƒì„±ëœ UI ìš”ì†ŒëŠ” ë²„íŠ¼ì´ ì•„ë‹ˆë”ë¼ë„ ì»¤ì„œ ì§„ì…, í´ë¦­, ë“œë˜ê·¸ ë“± ë‹¤ì–‘í•œ ì‚¬ìš©ì ì…ë ¥ì„ ê°ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.






## âš  ë¬¸ì œ ë°œê²¬
- EventTriggerê°€ ì ìš©ëœ UIê°€ Button ê¸°ë°˜ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì—, ScrollRect ë‚´ì—ì„œ ìŠ¤í¬ë¡¤ ë“œë˜ê·¸ ìš°ì„ ìˆœìœ„ê°€ ì •ìƒì ìœ¼ë¡œ ì „ë‹¬ë˜ì§€ ì•ŠëŠ” ë¬¸ì œê°€ í™•ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.
- ê·¸ ê²°ê³¼ í•´ë‹¹ UI ì´ë¯¸ì§€ê°€ ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ë¥¼ ì„ ì í•˜ë©°, ì´ë¯¸ì§€ê°€ ì•„ë‹Œ ë¹ˆ ì˜ì—­ì—ì„œë§Œ ë“œë˜ê·¸ ìŠ¤í¬ë¡¤ì´ ê°€ëŠ¥í•´ì¡ŒìŠµë‹ˆë‹¤.

ì¦‰, í´ë¦­ ë° ë§ˆìš°ìŠ¤ ì˜¤ë²„ê°€ ìš”êµ¬ë˜ëŠ” UIê°€ í¬í•¨ë  ê²½ìš° ScrollRectì˜ ì…ë ¥ ìš°ì„ ìˆœìœ„ê°€ ì¶©ëŒí•˜ë©´ì„œ ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤ ì²´ê°ì´ ì €í•˜ë˜ê³  UX ì¼ê´€ì„±ì´ ë¬´ë„ˆì§€ëŠ” ê²°ê³¼ê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤.






## âœ… í•´ê²° ë°©ë²•
- Unity ScrollRect/Scrollbar ì»´í¬ë„ŒíŠ¸ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  Wheel ì…ë ¥ + Custom ScrollBar UIë¥¼ ì§ì ‘ êµ¬í˜„í•˜ì—¬ ë™ì‘ì„ ì„¸ë°€í•˜ê²Œ ì œì–´í•˜ì˜€ìŠµë‹ˆë‹¤.
- Scroll ì˜ì—­ ìœ„ì— ë§ˆìš°ìŠ¤ê°€ ì˜¬ë¼ì™”ì„ ë•Œë§Œ Wheel ì…ë ¥ì„ í—ˆìš©í•˜ê³ , ìŠ¤í¬ë¡¤ì´ í•„ìš” ì—†ëŠ” ê²½ìš°ì—ëŠ” ScrollBarë¥¼ ìë™ìœ¼ë¡œ ìˆ¨ê¸°ëŠ” ë°©ì‹ìœ¼ë¡œ UI íš¨ìœ¨ì„±ê³¼ ì‹œê°ì  ì•ˆì •ì„±ì„ í™•ë³´í•˜ì˜€ìŠµë‹ˆë‹¤.
- ë“œë˜ê·¸, íœ , ìŠ¤í¬ë¡¤ë°” UI ì´ë™ì´ ëª¨ë‘ ë™ì¼í•œ ScrollValue ê¸°ë°˜ìœ¼ë¡œ ë™ê¸°í™”ë˜ë„ë¡ ì„¤ê³„í•˜ì˜€ìŠµë‹ˆë‹¤.


**1) Awake() ì´ˆê¸°í™”**
```csharp
private void Awake()
{
    UIHelper.AddEventTrigger(rootRect.gameObject, EventTriggerType.PointerEnter, delegate { OnPointerEnter();});
    UIHelper.AddEventTrigger(rootRect.gameObject, EventTriggerType.PointerExit,  delegate { OnPointerExit();  });

    if (scrollbarHandler != null)
    {
        UIHelper.AddEventTrigger(scrollbarHandler.gameObject, EventTriggerType.BeginDrag, delegate { HandlerDragStart(); });
        UIHelper.AddEventTrigger(scrollbarHandler.gameObject, EventTriggerType.Drag,      delegate { HandlerDrag();      });
    }

    barOriginalYSize = (!isScrollHorizontal && scrollbarBackground != null) ? scrollbarBackground.sizeDelta.y : barOriginalYSize;
    barOriginalXSize = ( isScrollHorizontal && scrollbarBackground != null) ? scrollbarBackground.sizeDelta.x : barOriginalXSize;

    limitMaxViewValue = GetMaxScrollValue();

    if (scrollbarHandler != null)
    {
        barMaxPos = scrollbarHandler.transform.position.y + barOriginalYSize;
        barMinPos = scrollbarHandler.transform.position.y;
    }
}

```
- Awake() ë‹¨ê³„ì—ì„œ ê°ì¢… Pointer/Drag ì´ë²¤íŠ¸ë¥¼ ì§ì ‘ ì—°ê²°í•˜ì—¬ ScrollRect ì—†ì´ ì…ë ¥ì„ ì œì–´í•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±í•˜ì˜€ìŠµë‹ˆë‹¤.
- ìŠ¤í¬ë¡¤ë°” í¬ê¸°, ì¢Œí‘œ, ìµœëŒ€ ì´ë™ëŸ‰ ë“±ì„ ì´ˆê¸° ê³„ì‚°í•˜ì—¬ Update êµ¬ê°„ì˜ ì—°ì‚°ëŸ‰ì„ ìµœì†Œí™”í•˜ì˜€ìŠµë‹ˆë‹¤.




**2) Update() í”„ë ˆì„ ë£¨í”„**
```csharp
private void Update()
{
    UpdateScrollVariables();      // ìŠ¤í¬ë¡¤ ë¹„ìœ¨ Â· ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ê³„ì‚°
    ProcessScrollbarVisibility(); // ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•œ ê²½ìš°ì—ë§Œ ë°” í‘œì‹œ
    if (isMouseEnter) HandleMouseScroll(); // UI ë‚´ë¶€ì¼ ë•Œë§Œ Wheel ì‚¬ìš©
    ApplyScrollToTarget();        // Content ì´ë™ ë°˜ì˜
    ApplyScrollbarPosition();     // ScrollBar UI ìœ„ì¹˜ ë™ê¸°í™”
}
```


**3) Pointer ì”ì… ì—¬ë¶€**

```csharp
private void OnPointerEnter() => isMouseEnter = true;
private void OnPointerExit()  => isMouseEnter = false;
```

- ë§ˆìš°ìŠ¤ê°€ UI ì˜ì—­ ë‚´ë¶€ì— ë“¤ì–´ì˜¨ ê²½ìš°ì—ë§Œ íœ  ì…ë ¥ì„ ìˆ˜ì‹ í•˜ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.
- ì¸ë²¤í† ë¦¬, ìƒì , ë³´ìƒ UI ë“± ë³µìˆ˜ UIê°€ ë„ì›Œì§ˆ ë•Œë„ ì¤‘ë³µ ìŠ¤í¬ë¡¤ì´ ë°œìƒí•˜ì§€ ì•Šë„ë¡ ì•ˆì •ì ìœ¼ë¡œ ì œì–´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.




**4) ScrollValue ê³„ì‚°**
```csharp
private void UpdateScrollVariables()
{
    if (scrollbarHandler == null) return;

    testMousePos = Input.mousePosition.y;
    currBarY     = scrollbarHandler.transform.position.y;
    middlePos    = scrollbarHandler.transform.position.y + (barSize / 2f);
    percent = Mathf.InverseLerp(0f, barOriginalYSize - scrollbarHandler.rect.height, scrollbarHandler.anchoredPosition.y);

    if (isUpdateSize)
        limitMaxViewValue = GetMaxScrollValue();
}
```
- ìŠ¤í¬ë¡¤ ì§„í–‰ë¥ (percent)ê³¼ í•¸ë“¤ ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤ ìƒíƒœë¥¼ ê°±ì‹ í•˜ë„ë¡ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
- Content ì‚¬ì´ì¦ˆê°€ ë³€ê²½ë  ê²½ìš° ì¦‰ì‹œ limitMaxViewValueë¥¼ ë‹¤ì‹œ ê³„ì‚°í•˜ì—¬ í™•ì¥í˜• ì½˜í…ì¸ ì—ë„ ëŒ€ì‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.


**5) ìŠ¤í¬ë¡¤ ê°€ëŠ¥ ì‹œì—ë§Œ Bar UI ìë™ í™œì„±í™”**
```csharp
private void ProcessScrollbarVisibility()
{
    if (!scrollOverRootRect) return;

    bool noScroll = limitMaxViewValue <= 0;
    scrollbarHandler?.gameObject.SetActive(!noScroll);
    scrollbarBackground?.gameObject.SetActive(!noScroll);

    if (noScroll) return;
}
```
- ì½˜í…ì¸  ë†’ì´ê°€ Viewë³´ë‹¤ ì‘ë‹¤ë©´ ìŠ¤í¬ë¡¤ë°”ë¥¼ ìë™ìœ¼ë¡œ ìˆ¨ê¸°ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.
- UIë¥¼ ë¶ˆí•„ìš”í•˜ê²Œ ì°¨ì§€í•˜ì§€ ì•Šìœ¼ë©°, ìŠ¤í¬ë¡¤ í•„ìš” ì‹œì—ë§Œ í‘œì‹œë˜ëŠ” UXê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.


**6) ë§ˆìš°ìŠ¤ íœ **
```csharp
private void HandleMouseScroll()
{
    adjustedSensitivity = (limitMaxViewValue == 0) ? sensitivity : sensitivity * (1f / limitMaxViewValue);

    float wheel = Input.GetAxisRaw("Mouse ScrollWheel") * adjustedSensitivity;
    currentScrollValue += reverseWheel ? -wheel : wheel;
    currentScrollValue = Mathf.Clamp(currentScrollValue, minScrollValue, maxScrollValue);
}
```
- ìŠ¤í¬ë¡¤ ë¯¼ê°ë„ëŠ” ì½˜í…ì¸  ê¸¸ì´ì— ë”°ë¼ ìë™ ìŠ¤ì¼€ì¼ë§ë˜ë©°, ë¹ ë¥¸Â·ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤ì´ ëª¨ë‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.
- íœ  ë°©í–¥ ë°˜ì „ ì˜µì…˜ë„ ì§€ì›í•˜ì—¬ ì œì‘ìÂ·ì‚¬ìš©ì ê²½í—˜ì— ë§ê²Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


**7) ScrollBar ìœ„ì¹˜ UI ì‹¤ì‹œê°„ ë°˜ì˜**
```csharp
private void ApplyScrollbarPosition()
{
    if (scrollbarHandler == null || scrollbarBackground == null) return;

    if (isScrollHorizontal)
    {
        SetScrollBarSizeX();
        float dir = reverseRect ? -1f : 1f;
        scrollbarHandler.anchoredPosition = Vector3.Lerp(scrollbarHandler.anchoredPosition,
                                                         Vector3.left * currentScrollValue * limitMaxBarValue * dir,
                                                         Time.deltaTime * smoothDamp );
    }
    else
    {
        SetScrollBarSizeY();
        float dir = reverseRect ? 1f : -1f;
        scrollbarHandler.anchoredPosition = Vector3.Lerp( scrollbarHandler.anchoredPosition,
                                                          Vector3.up * currentScrollValue * limitMaxBarValue * dir,
                                                          Time.deltaTime * smoothDamp);
    }
}
```
- ScrollValue ê°’ë§Œ ë°”ë€Œë©´ Contentì™€ ScrollBarê°€ ë™ì‹œì— ì´ë™í•˜ë„ë¡ êµ¬ì¡°ë¥¼ í†µì¼í•˜ì˜€ìŠµë‹ˆë‹¤.
- UI í‘œì‹œ ìƒíƒœ, ë“œë˜ê·¸ ë°˜ì‘, Wheel ì…ë ¥ì´ ëª¨ë‘ í•˜ë‚˜ì˜ ë³€ìˆ˜ë¥¼ ê³µìœ í•˜ë¯€ë¡œ ì¶©ëŒ ì—†ì´ ë™ì‘í•©ë‹ˆë‹¤.

---
