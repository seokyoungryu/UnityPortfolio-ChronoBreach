# ğŸ® Unity3D Portfolio RPG Game - Chrono Breach


# âš™ï¸ UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨
í”„ë¡œì íŠ¸ì˜ ì£¼ìš” ì‹œìŠ¤í…œ êµ¬ì¡°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” UML ë‹¤ì´ì–´ê·¸ë¨ì…ë‹ˆë‹¤.
<img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UML_F4.drawio.png" alt="UML Diagram" width="1000" />



 ### [ğŸ§© **UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ì—´ê¸°**](https://app.diagrams.net/?url=https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/refs/heads/main/UML_F4.drawio) (ctrl + wheelë¡œ ì¤Œ ì•„ì›ƒ)

# ğŸ“¹ ë™ì˜ìƒ ë§í¬
**ë™ì˜ìƒ í™”ì§ˆì„ 4kë¡œ ì„ íƒí•˜ì—¬ ì‹œì²­í•´ì£¼ì‹œë©´ ê°ì‚¬í•©ë‹ˆë‹¤.** 
<a href="https://www.youtube.com/watch?v=sTdEx9n8rMI" target="_blank">
  <img src="https://img.youtube.com/vi/sTdEx9n8rMI/maxresdefault.jpg" alt="Unity Portfolio (4K)" style="width:100%;">
</a>

### [ğŸ¬ **ìœ íŠœë¸Œ ì˜ìƒ ë°”ë¡œ ë³´ê¸°**](https://www.youtube.com/watch?v=sTdEx9n8rMI)


---

# ğŸ› ï¸ ì •ë³´

- **Unity Version**: 2021.3.17f1
- **ì œì‘ ê¸°ê°„**: 1ë…„ 2ê°œì›”
- **ê²Œì„ ì¥ë¥´**: 3D Action RPG
- **íƒ€ê²Ÿ í”Œë ›í¼**: PC
- **ì´ë©”ì¼**: whtkrl@gmail.com
- **ì œì‘ì¸ì›**: 1ëª…
---

# â³ í•µì‹¬ ê¸°ìˆ  íŒŒíŠ¸

## ğŸ“Œ Dungeon System
**ëª¨ë“ˆí˜• í™•ì¥ êµ¬ì¡°ì˜ ìœ ì—°í•œ ë˜ì „ UML**ğŸ¯
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UML_D1.png" width="650"/> </p>


## ğŸ¯ ì„¤ê³„ ëª©ì 
ì´ˆê¸°ì—ëŠ” ë‹¨ìˆœíˆ ëª¨ë“  ì  ì²˜ì¹˜ ì‹œ í´ë¦¬ì–´ë˜ëŠ” êµ¬ì¡°ë§Œ êµ¬í˜„í•˜ë ¤ í–ˆìœ¼ë‚˜, ë˜ì „ë³„ë¡œ ê³ ìœ í•œ ëª©í‘œì™€ ê·œì¹™ì„ ì œê³µí•˜ë©´ ê²Œì„ í”Œë ˆì´ì˜ ê¹Šì´ì™€ ë‹¤ì–‘ì„±ì´ í¬ê²Œ í–¥ìƒëœë‹¤ê³  íŒë‹¨í•˜ì—¬ í˜„ì¬ì˜ ëª¨ë“ˆí˜•Â·í™•ì¥í˜• êµ¬ì¡°ë¡œ ë°œì „ì‹œì¼°ìŠµë‹ˆë‹¤.  

ì„¤ê³„ ê³¼ì •ì—ì„œëŠ” ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ íŠ¹íˆ ì¤‘ì ì ìœ¼ë¡œ ê³ ë ¤í–ˆìŠµë‹ˆë‹¤.  

- **ìœ ì§€ë³´ìˆ˜ì„±**: ë˜ì „ë³„ ë¡œì§ ë¶„ë¦¬ ë° ë…ë¦½ ê´€ë¦¬  
- **í™•ì¥ì„±**: ë°ì´í„°ë§Œ êµì²´í•´ ë‹¤ì–‘í•œ ë˜ì „ ìœ í˜• ì¶”ê°€ ê°€ëŠ¥  

---

## ğŸ¯ Dungeon êµ¬ì„± ìš”ì†Œ 
ì•„ë˜ êµ¬ì„±ë“¤ì€ ë˜ì „ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë°ì´í„°ë¥¼ ê°„ê²°í•˜ê²Œ í‘œí˜„í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.  

## Title
- ë˜ì „ì˜ ì´ë¦„, ìœ í˜•, ì„¤ëª… ë“±  
- ë˜ì „ì„ ì‹ë³„í•˜ê³  UI ë° ì‹œìŠ¤í…œì—ì„œ í™œìš©ë˜ëŠ” ê¸°ë³¸ ì •ë³´  
- **( Normal, Rush, Protect, Rescuer, Target )**
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Title.png" width="650"/> </p>

  
## Category
- ì‚¬ìš©í•˜ëŠ” Controller ì„¤ì •.
```csharp
[CreateAssetMenu(menuName ="Map/Dungeon Category/Normal ", fileName ="NormalDungeonCategory")]
public class NormalDungeonCategory : BaseDungeonCateogry
{
    public override PlayerStateController InitControllerSetting(BaseDungeonTitle title)
    {
        PlayerStateController originController = title.OriginController;
        originController.allowStates.Clear();
        originController.allowStates.Add(originController.GetState<MoveState>());
        originController.allowStates.Add(originController.GetState<AttackState>());
        originController.allowStates.Add(originController.GetState<RollState>());
        originController.allowStates.Add(originController.GetState<SkillState>());
        originController.allowStates.Add(originController.GetState<DamagedState>());
        originController.allowStates.Add(originController.GetState<CounterAttackState>());
        originController.allowStates.Add(originController.GetState<DeadState>());
        originController.allowStates.Add(originController.GetState<DashState>());
        return originController;
    }
}
```
- Normal Categoryì—ì„œëŠ” í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ Stateë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.

## Condition
- ë˜ì „ì— ì…ì¥í•˜ê¸° ìœ„í•œ ì¡°ê±´ì„ ëª…ì‹œ  
  - í”Œë ˆì´ì–´ ë ˆë²¨  
  - í•„ìš” ì•„ì´í…œ  
  - íŠ¹ì • ìŠ¤í…Œì´ì§€ ì„ í–‰ ì—¬ë¶€  

## Function
- ë˜ì „ ì§„í–‰ ì „ì²´ë¥¼ ë‹´ë‹¹í•˜ëŠ” í•µì‹¬ í”„ë¡œì„¸ìŠ¤  
  - ë¼ìš´ë“œ ì‹œì‘  
  - ëª¬ìŠ¤í„°/ë³´ìŠ¤ ìŠ¤í°  
  - í´ë¦¬ì–´ ì¡°ê±´ ì²´í¬  
  - ì¢…ë£Œ ë° ë³´ìƒ ì²˜ë¦¬  

```csharp
[CreateAssetMenu(menuName = "Map/Dungeon Function/Normal Function ", fileName = "NormalFunction")]
public class NormalDungeonFunction : BaseDungeonFunction<NormalDungeonTitle>
{
    public override void ExcuteProcess(NormalDungeonTitle title)
    {
        SoundManager.Instance.PlayBGM_CrossFade(title.BaseBGM, 4f);
        title.SpawnData.dungeon = title.dungeonCoroutine;
        title.DungeonMapData.ExcuteTeleportMap();

        title.SpawnData.onExcuteBoss += () => { SoundManager.Instance.PlayBGM_CrossFade(title.BossBGM, 3f); };
        ScenesManager.Instance.OnExcuteAfterLoading = () => title.DungeonMapData.ExcuteTeleportController(title.ExcuteController, title.DungeonSpawnPosition);
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.SettingSpawnPositionList(title.DungeonSpawnPosition);
        ScenesManager.Instance.OnExcuteAfterLoading += () => GameManager.Instance.Cam.SetTarget(title.ExcuteController.gameObject);
        ScenesManager.Instance.OnExcuteAfterLoading += () => GameManager.Instance.Cam.ResetRotation();
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.StartWave();
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.CreateExistBarrier();
        ScenesManager.Instance.OnExcuteAfterLoading += () => CommonUIManager.Instance.ExcuteGlobalNotifer(title.InitGlobalNotifier);

        title.SpawnData.onCompleteDungeon += () => QuestManager.Instance.ReceiveReport(QuestCategoryDefines.COMPLETE_DUNGEON, title.TaskTarget, 1);
        GameManager.Instance.Player.playerStats.OnDead_ += () => title?.SpawnData?.ExcuteFailProcess();
    }
}

```

## Reward
- í´ë¦¬ì–´ ë³´ìƒ ì •ë³´  
  - ê²½í—˜ì¹˜
  - ëª…ì„±ì¹˜
  - ìŠ¤í‚¬í¬ì¸íŠ¸
  - ì•„ì´í…œ  
  - ê³¨ë“œ  
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/R1.png" width="700" style="display:inline-block;"/>
  
## MapData
- ë˜ì „ì— ì‚¬ìš©ë˜ëŠ” ë˜ì „ Scene indexì™€ ìœ„ì¹˜, íšŒì „ ë“±ì˜ ë§µ ì •ë³´.

## SpawnPosition
- ë˜ì „ ë‚´ ìœ„ì¹˜ ì •ë³´ êµ¬ì„± ìš”ì†Œ  
  - í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜  
  - Enemy/Boss ìŠ¤í° ì§€ì   
  - íŠ¸ë¦¬ê±° ì´ë²¤íŠ¸ ìœ„ì¹˜  

  <p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜1.png" width="700" style="display:inline-block;"/>
-OnValidate() í•©ìˆ˜ë¡œ ë°‘ì—ìˆëŠ” Map Position Prefabì˜ ì •ë³´ë¥¼ ìë™ ì„¸íŒ…í•©ë‹ˆë‹¤.

<div align="center">
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜2.png" width="300" style="display:inline-block;"/>
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜3.png" width="300" style="display:inline-block;"/>
</div>
- OnDrawGizmos() í•¨ìˆ˜ë¡œ Root Transformì˜ child Transformì˜ ìœ„ì¹˜ë“¤ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ë©° positions ë¦¬ìŠ¤íŠ¸ì— ìë™ ì¶”ê°€í•©ë‹ˆë‹¤.

## SpawnData 
- ì „íˆ¬ êµ¬ì„±ì— í•„ìš”í•œ ëª¨ë“  ìŠ¤í° ë° ë¼ìš´ë“œ ë°ì´í„°  
  - Enemy/Boss ìŠ¤í° ë¦¬ìŠ¤íŠ¸
  - Playable AI ë¦¬ìŠ¤íŠ¸
  - ì´ë™ ë¶ˆê°€ ë²½ ì •ë³´
  - ì›¨ì´ë¸Œ/ë¼ìš´ë“œ êµ¬ì„±   
- **( Normal, Rush, Protect, Rescuer, Target, TimeAttackRush )**
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/SpawnD1.png" width="650"/> </p>



## âš¡ Dash System
<p align="center">  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Dash.gif" width="400" style="display:inline-block;"/>
 
- ê³ ì† íƒ€ê²© ê¸°ë°˜ì˜ ì§€í˜•Â·ì  ê°ì§€í˜• ëŒ€ì‹œ ì‹œìŠ¤í…œ 

ëŒ€ì‹œ ì‹œìŠ¤í…œì€ ë‹¨ìˆœí•œ ëŒì§„ì´ ì•„ë‹ˆë¼ ì§€í˜•, ì , ì¥ì• ë¬¼, ì¹´ë©”ë¼, ì¿¨íƒ€ì„ UIë¡œ êµ¬ì„±ëœ ì „íˆ¬ ì‹œìŠ¤í…œìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì•„ë˜ ë‘ ê°€ì§€ ëª©í‘œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤.
- **ì •í™•ì„± : ì•ˆì „í•˜ê²Œ ì´ë™ ê°€ëŠ¥í•œ ì§€ì ë§Œ ê³„ì‚°í•˜ì—¬ ì˜¤ë™ì‘ì„ ìµœì†Œí™”**
- **ì „ìˆ ì„± : ì Â·ì§€ë©´Â·ì¥ì• ë¬¼ íŒì •ì„ ì¡°í•©í•´ ì „ëµì ìœ¼ë¡œ ëŒ€ì‹œë¥¼ í™œìš© ê°€ëŠ¥**

## â­ Dash ì„¤ê³„ í•µì‹¬ ìš”ì†Œ
<div align="center">
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/G1.gif" width="450" style="display:inline-block;"/>
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/G2.gif" width="450" style="display:inline-block;"/>
</div>

- ëŒ€ì‹œëŠ” ì•„ë˜ì™€ ê°™ì€ êµ¬ì¡°ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.

## Target Detect
- ëŒ€ìƒ ìœ„ì¹˜ ê³„ì‚°
  - BaseController ì—¬ë¶€ì— ë”°ë¼ í”¼ê²© ì¤‘ì‹¬ì  ë˜ëŠ” Transform ìœ„ì¹˜ë¥¼ íƒ€ê¹ƒ ì¢Œí‘œë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ì§€ë©´ ê²€ì¶œ ì‹œ ëŒ€ì‹œ ë¶ˆê°€
  - CheckDetectGround(targetDir, distance) ì—ì„œ ì§€ë©´ì´ ê°ì§€ë˜ë©´ í•´ë‹¹ ìœ„ì¹˜ëŠ” ëŒ€ì‹œ ëŒ€ìƒì—ì„œ ì œì™¸ë©ë‹ˆë‹¤.
- ì¥ì• ë¬¼ ê²€ì¶œ ì‹œ ëŒ€ì‹œ ë¶ˆê°€
  - CheckDetectObstacle(targetDir, distance) ê²°ê³¼ ì¥ì• ë¬¼ì´ ì°¨ë‹¨í•˜ê³  ìˆìœ¼ë©´ ëŒ€ì‹œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
- ê·¼ê±°ë¦¬ ëŒ€ìƒ ì •ë°€ ì²´í¬
  - íƒ€ê¹ƒì´ targetingAllowDistance ì´ë‚´ë¼ë©´, ë” ì¢ì€ ì¤‘ì•™ ìŠ¤í¬ë¦° ì˜ì—­(targetingLimitScreenPoint) ì•ˆì— ìˆì„ ë•Œë§Œ ëŒ€ì‹œë¥¼ í—ˆìš©í•©ë‹ˆë‹¤.
- ì¼ë°˜ íƒ€ê¹ƒíŒ… ì˜ì—­ ì²´í¬
  - ê·¼ê±°ë¦¬ ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ëª»í•˜ë”ë¼ë„, ë„“ì€ ê¸°ì¤€ ìŠ¤í¬ë¦° ì˜ì—­(limitDistance) ì•ˆì— ìœ„ì¹˜í•˜ë©´ ëŒ€ì‹œ ê°€ëŠ¥ ëŒ€ìƒìœ¼ë¡œ ì¸ì •í•©ë‹ˆë‹¤.
- ë‘ ì¡°ê±´ ëª¨ë‘ ë²—ì–´ë‚˜ë©´ ëŒ€ì‹œ ë¶ˆê°€
  - ìŠ¤í¬ë¦° ê¸°ì¤€ì ì„ ë²—ì–´ë‚˜ê±°ë‚˜ ê±°ë¦¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•  ê²½ìš° ëŒ€ì‹œëŠ” í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
```csharp
  private bool CheckCanDashTarget(Transform targetTr)
    {
        BaseController targetCon = targetTr.GetComponent<BaseController>();
        Vector3 targetPos = targetCon != null ? targetCon.damagedPosition.position : targetTr.position;
        Vector2 point = cam.MainCam.WorldToScreenPoint(targetPos);
        targetDir = (targetPos - centerPosition).normalized;
        float distance = (targetPos - (controller.transform.position + (Vector3)centerOffset)).magnitude;

        gizmoObstacleDir = targetDir;
        gizmoObstacleDistance = distance;

        //ë•…ì¼ê²½ìš°
        if (CheckDetectGround(targetDir, distance))
        {
            return false;
        }

        ///íƒ€ê²Ÿ ìœ„ì¹˜ì— ë ˆì´ì–´ ì´ì„œ ì¥ì• ë¬¼ ìˆë‚˜ íŒë‹¨.
        if (CheckDetectObstacle(targetDir, distance))
        {
            return false;
        }

        //íƒ€ê²ŸíŒ…ì¼ ê²½ìš° 
        if (distance <= targetingAllowDistance)
        {
            if (centerScreenPoint.x + targetingLimitScreenPoint.x >= point.x && centerScreenPoint.x - targetingLimitScreenPoint.x <= point.x &&
            centerScreenPoint.y + targetingLimitScreenPoint.y >= point.y && centerScreenPoint.y - targetingLimitScreenPoint.y <= point.y)
                return true;
        }

        if (centerScreenPoint.x + limitDistance.x >= point.x && centerScreenPoint.x - limitDistance.x <= point.x &&
            centerScreenPoint.y + limitDistance.y >= point.y && centerScreenPoint.y - limitDistance.y <= point.y)
        {
            return true;
        }

        return false;
    }

```

## Ground Check
- ëŒ€ì‹œ ê°€ëŠ¥í•œ ì§€ì ì„ ì°¾ê¸° ìœ„í•´ ëª©í‘œì ê¹Œì§€ì˜ ìˆ˜í‰ ì´ë™ ê±°ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¼ì • ê°„ê²©ìœ¼ë¡œ ì§€ë©´ì„ ìƒ˜í”Œë§í•©ë‹ˆë‹¤.
- ì‘ë™ ë°©ì‹
  - í”Œë ˆì´ì–´ â†’ íƒ€ê¹ƒ ë°©í–¥ìœ¼ë¡œ ì¼ì • Intervalë§Œí¼ ì „ì§„
  - ê° ì‹œì ì—ì„œ ì•„ë˜ë¡œ SphereCast
  - ì ì´ ìˆëŠ” ìœ„ì¹˜ë©´ Skip
  - ìµœì´ˆë¡œ ì•ˆì „í•œ ì§€ë©´ì„ ì°¾ìœ¼ë©´ ê·¸ ìœ„ì¹˜ë¡œ ì´ë™ í™•ì •

ğŸ”‘ í•µì‹¬ ì½”ë“œ
```csharp
private bool CheckCanDashGround()
{
    sumInterval = 0f;
    targetDirFromDashPos = (dashTargetTr.position - tmpDashPosition);
    groundDistance = targetDirFromDashPos.magnitude;
    groundSumCount = (int)((groundDistance - minDetectTargetDistance) / groundDetectInterval);
    currentTargetHeight = (dashTargetTr.position - controller.transform.position).y;

    if (currentTargetHeight < minDetectHeight || currentTargetHeight > maxDetectHeight)
        return false;

    targetDirFromDashPos.y = 0f;
    targetDirFromDashPos.Normalize();

    for (int i = 0; i < groundSumCount; i++)
    {
        startPos = tmpDashPosition + targetDirFromDashPos * sumInterval + Vector3.up * groundStartYOffset;
        sumInterval += groundDetectInterval;

        if (DetectEnemy(startPos))
            continue;

        if (Physics.SphereCast(startPos, groundDetectRadius, -Vector3.up,out groundCheckRayHit, groundYRange, groundLayer))
        {
            canDashPosition = groundCheckRayHit.point;
            return true;
        }
        else
            canDashPosition = Vector3.zero;
    }
    return false;
}
```

## Enemy Detection
- ëŒ€ì‹œ ê²½ë¡œì— ì ì´ ìˆëŠ”ì§€ ê²€ì‚¬í•´ ì¶©ëŒ ê°ì§€ ì‹œ Skip ë˜ëŠ” Hit ì²˜ë¦¬í•©ë‹ˆë‹¤.

ğŸ”‘ í•µì‹¬ ì½”ë“œ
```csharp
private bool DetectEnemy(Vector3 startPosition)
{
    RaycastHit groundHit;

    // 1) ì§€ë©´ì´ ì—†ëŠ” ê²½ìš° - ì•ˆì „
    if (!Physics.Raycast(startPosition, -Vector3.up, out groundHit, groundYRange, groundLayer))
        return true;

    // 2) ì§€ë©´ê¹Œì§€ SphereCast ì‹œ ì  ê°ì§€
    if (Physics.SphereCast(startPosition, groundDetectRadius, -Vector3.up,
        out groundCheckRayHit, groundHit.point.y, enemyLayer))
    {
        drawEnemyHitPoints.Add(groundCheckRayHit.point);
        return true;
    }

    // 3) ì‹œì‘ ì§€ì ì— ì ì´ ìˆëŠ”ì§€ ê²€ì‚¬
    if (Physics.OverlapSphereNonAlloc(startPosition, groundDetectRadius,
        groundEnemyColls, enemyLayer) > 0)
    {
        drawEnemyHitPoints.Add(startPosition);
        return true;
    }

    return false;
}
```

## Obstacle Check
<p align="center">  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Ground.gif" width="400" style="display:inline-block;"/>
 
- ëŒ€ì‹œ ê²½ë¡œì— ì¥ì• ë¬¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ ì‚¬ì „ ê²€ì¶œí•©ë‹ˆë‹¤.
  - OverlapSphereNonAlloc ê¸°ë°˜ ì¶©ëŒ ì˜ˆì¸¡ ë° ìµœì í™”
- ì¥ì• ë¬¼ê³¼ ì¶©ëŒí•˜ë©´ Target ìë™ ë³€ê²½ ë˜ëŠ” ëŒ€ì‹œ ì·¨ì†Œ

## Dash Movement + Camera + UI
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UI1.gif" width="400" style="display:inline-block;"/>

- íƒ€ê¹ƒ UIë¡œ í˜„ì¬ ì„ íƒëœ ëŒ€ìƒ ì‹œê°í™” 
- ëŒ€ì‹œ ì´ë™ì´ í—ˆìš©ë˜ë©´ ë‹¤ìŒ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.
  - ì¹´ë©”ë¼ FOV ë³€í™”
  - ì›ê±°ë¦¬/ê·¼ê±°ë¦¬ ëŒ€ì‹œë³„ SmoothSpeed ìë™ ì¡°ì ˆ
  - ì„±ê³µ ì¹´ìš´íŠ¸ UI ì—…ë°ì´íŠ¸
  - ëŒ€ì‹œ ìŠ¤íƒ ê¸°ë°˜ ì¿¨íƒ€ì„ íšŒë³µ

```csharp
 private IEnumerator DashMoveProcess_Co()
    {
        if (dashTargetTr == null)
            yield break;
        float endTime = dashClip.EndTime;

        if (CanTeleportToTarget(dashTargetTr))
        {
            StartCoroutine(DashCameraProcess_Co(false));
            yield return new WaitForSeconds(farDelayFOVMoveTime);
            controller.RotateToTarget(dashTargetTr.position);
            controller.myAnimator.CrossFade(dashClip.AnimationName, 0.1f);
            controller.TranslatePosition(canDashPosition);
            controller.StartCoroutine(DashDamageProcess_Co());
        }
        else
        {
            StartCoroutine(DashCameraProcess_Co(true));
            yield return new WaitForSeconds(nearDelayFOVMoveTime);
            controller.RotateToTarget(dashTargetTr.position);
            controller.myAnimator.CrossFade(dashClip.AnimationName, 0.1f);
            controller.StartCoroutine(DashDamageProcess_Co());
        }

        yield return new WaitForSeconds(dashClip.EndTime);
        doneDashState = true;
        dashTargetTr = null;
    }
 

```


# â³ íŠ¸ëŸ¬ë¸” ìŠˆíŒ…
## ğŸ¨ ë©”í…Œë¦¬ì–¼ ìµœì í™” ê³¼ì •
- NPCë‚˜ ëª¬ìŠ¤í„°ë¥¼ ìƒì„±í•  ë•Œ, ìºë¦­í„°ë³„ë¡œ ì§€ì •ëœ ìƒ‰ìƒì„ ì ìš©í•˜ê¸° ìœ„í•´ ë©”í…Œë¦¬ì–¼ ì»¬ëŸ¬ ê°’ì„ ë³€ê²½í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.
- ì¦‰, ìŠ¤í°ëœ ìºë¦­í„°ë§ˆë‹¤ ê³ ìœ í•œ ìƒ‰ìƒì„ ì„¤ì •í•˜ëŠ” ê³¼ì •ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ë©”í…Œë¦¬ì–¼ì„ ìˆ˜ì •í•˜ëŠ” ë¡œì§ì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤.

## âš  ë¬¸ì œ ë°œìƒ
- ë©”í…Œë¦¬ì–¼ì˜ ìƒ‰ìƒì„ ë³€ê²½í•˜ëŠ” ê³¼ì •ì—ì„œ ê¸°ì¡´ ë©”í…Œë¦¬ì–¼ì„ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, Unityê°€ ë‚´ë¶€ì ìœ¼ë¡œ ìƒˆë¡œìš´ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ë³€ê²½ì„ ì ìš©í•˜ê³  ìˆë‹¤ëŠ” ì‚¬ì‹¤ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.

ì´ë ‡ê²Œ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ê°€ ê°œë³„ ê°ì²´ë§ˆë‹¤ ìƒì„±ë˜ë©´, ê²°ê³¼ì ìœ¼ë¡œ GPU Batching(ë“œë¡œìš°ì½œ ë³‘í•©)ì´ ê¹¨ì§€ëŠ” í˜„ìƒì´ ë°œìƒí•˜ë©°
- NPC, ëª¬ìŠ¤í„°ê°€ ë§ì•„ì§ˆìˆ˜ë¡ Draw Callì´ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€í•´ ì„±ëŠ¥ ì €í•˜ë¡œ ì´ì–´ì§€ëŠ” ì¦ìƒì´ ìƒê²¼ìŠµë‹ˆë‹¤.

## ğŸ” ì›ì¸ ë¶„ì„

Unityì˜ ë©”í…Œë¦¬ì–¼ êµ¬ì¡°ìƒ renderer.materialì„ ìˆ˜ì •í•˜ë©´

ê¸°ì¡´ ë©”í…Œë¦¬ì–¼ì€ ê³µìœ ëœ ìƒíƒœ

ìˆ˜ì • ìˆœê°„ Rendererë§ˆë‹¤ ê³ ìœ í•œ ì¸ìŠ¤í„´ìŠ¤(Material Instance)ë¥¼ ìƒì„±
í•˜ê²Œ ë©ë‹ˆë‹¤.

ì¦‰, ìƒ‰ìƒ í•˜ë‚˜ë§Œ ë°”ë€Œì–´ë„ ì „ë¶€ ë‹¤ë¥¸ ë©”í…Œë¦¬ì–¼ë¡œ ì¸ì‹ë˜ê¸° ë•Œë¬¸ì—
Static/Dynamic Batchingì´ ì ìš©ë˜ì§€ ì•Šê³  Draw Callì´ ë¶ˆí•„ìš”í•˜ê²Œ í™•ëŒ€ë˜ëŠ” ê²ƒì´ ì›ì¸ì´ì—ˆìŠµë‹ˆë‹¤.


## â³ íƒ€ì„ë¼ì¸

ì•„ë˜ëŠ” ê° ì£¼ìš” ì¥ë©´ê³¼ ê·¸ì— í•´ë‹¹í•˜ëŠ” ì‹œê°„ì…ë‹ˆë‹¤.

| **ì‹œê°„**  | **ë‚´ìš©**                  |
|:---------:|:--------------------------|
| 0:00:00   | **ì „íˆ¬ ì¥ë©´ í•˜ì´ë¼ì´íŠ¸**  |
| 0:02:38   | **íƒ€ì´í‹€ í™”ë©´**            |
| 0:03:32   | **ì»¤ë§¨ë“œì°½**               |
| 0:08:45   | **ì—°ìŠµëª¨ë“œ**               |
| 0:12:18   | **ì¹´ë©”ë¼ ì„¤ëª…**            |
| 0:15:42   | **í”Œë ˆì´ì–´ State**         |
| 0:22:50   | **ì•„ì´í…œ íšë“ UI**         |
| 0:28:21   | **ì¥ë¹„ì°½**                 |
| 0:31:06   | **ì ì¬ëŠ¥ë ¥**               |
| 0:34:06   | **í€µ ìŠ¬ë¡¯**               |
| 0:34:57   | **ìŠ¤í‚¬ì°½**                 |
| 0:36:56   | **ìŠ¤í‚¬ ì‹œì—°**              |
| 0:55:46   | **í€˜ìŠ¤íŠ¸ / ë‹¤ì´ì–´ë¡œê·¸**    |
| 1:04:00   | **í€˜ìŠ¤íŠ¸ ëª©ë¡ ì°½**         |
| 1:06:02   | **ì‹œì¦Œ 1 ì§„í–‰ / ë˜ì „ 1-1 (ì¼ë°˜)**  |
| 1:08:19   | **ë˜ì „ ì—”íŠ¸ë¦¬ ì°½**         |
| 1:16:12   | **ì‹œì¦Œ 2 ì§„í–‰ / ë˜ì „ 2-1 (ì¸ì§ˆ êµ¬ì¶œ)** |
| 1:27:42   | **ë˜ì „ 2-2 (ê±´ë¬¼ ë³´í˜¸)**               |
| 1:33:01   | **ì‹œì¦Œ 3 ì§„í–‰ / ë˜ì „ 3-1 (ì„¬ë©¸)** |
| 1:39:03   | **ë˜ì „ 3-2 (ì„œë°”ì´ë²Œ íƒ€ì„ì–´íƒ)**               |
| 1:45:29   | **ì‹œì¦Œ 4 ì§„í–‰ / ë˜ì „ 4-1 (íƒ€ê²Ÿ ì œê±°)** |
| 1:54:25   | **ì‹œì¦Œ 5 ì§„í–‰ / ë˜ì „ 5-1 (ëª©í‘œë³´í˜¸ follow)** |
| 2:03:15   | **ë˜ì „ 5-2 (ëª©í‘œë³´í˜¸ waypoint)**               |
| 2:14:13   | **EditorTool - AiInfo**    |
| 2:16:08   | **EditorTool - Sort & Combine** |
| 2:20:27   | **EditorTool - Effect**    |
| 2:20:55   | **EditorTool - Item**      |
| 2:24:07   | **EditorTool - Potential** |
| 2:25:47   | **EditorTool - Sound**     |
| 2:26:27   | **Editor - Range Projectile Info** |
| 2:30:13   | **END**                    |

---
