# ğŸ® Unity3D Portfolio RPG Game - Chrono Breach


## ğŸ“š ëª©ì°¨
- [UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨](#-uml-í´ë˜ìŠ¤-ë‹¤ì´ì–´ê·¸ë¨)
- [ë™ì˜ìƒ ë§í¬](#-ë™ì˜ìƒ-ë§í¬)
- [ì •ë³´](#-ì •ë³´)
- [í•µì‹¬ ê¸°ìˆ  íŒŒíŠ¸](#-í•µì‹¬-ê¸°ìˆ -íŒŒíŠ¸)
  - [Dungeon System](#-dungeon-system)
  - [Dash System](#-dash-system)
- [íŠ¸ëŸ¬ë¸” ìŠˆíŒ…](#-íŠ¸ëŸ¬ë¸”-ìŠˆíŒ…)


# âš™ï¸ UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨
í”„ë¡œì íŠ¸ì˜ ì£¼ìš” ì‹œìŠ¤í…œ êµ¬ì¡°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” UML ë‹¤ì´ì–´ê·¸ë¨ì…ë‹ˆë‹¤.
<img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UML_F4.drawio.png" alt="UML Diagram" width="1000" />



 ### [ğŸ§© **UML í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨ ì—´ê¸°**](https://app.diagrams.net/?url=https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/refs/heads/main/UML_F4.drawio) (ctrl + wheelë¡œ ì¤Œ ì•„ì›ƒ)

# ğŸ“¹ ë™ì˜ìƒ ë§í¬
**ë™ì˜ìƒ í™”ì§ˆì„ 4kë¡œ ì„ íƒí•˜ì—¬ ì‹œì²­í•´ì£¼ì‹œë©´ ê°ì‚¬í•©ë‹ˆë‹¤.** 
<a href="https://www.youtube.com/watch?v=sTdEx9n8rMI" target="_blank">
  <img src="https://img.youtube.com/vi/sTdEx9n8rMI/maxresdefault.jpg" alt="Unity Portfolio (4K)" style="width:100%;">
</a>

### [ğŸ¬ **ìœ íŠœë¸Œ ì˜ìƒ ë°”ë¡œ ë³´ê¸°**](https://www.youtube.com/watch?v=sTdEx9n8rMI)


---

# ğŸ› ï¸ ì •ë³´

- **Unity Version**: 2021.3.17f1
- **ì œì‘ ê¸°ê°„**: 1ë…„ 2ê°œì›”
- **ê²Œì„ ì¥ë¥´**: 3D Action RPG
- **íƒ€ê²Ÿ í”Œë ›í¼**: PC
- **ì´ë©”ì¼**: whtkrl@gmail.com
- **ì œì‘ì¸ì›**: 1ëª…
---

# â³ í•µì‹¬ ê¸°ìˆ  íŒŒíŠ¸

## ğŸ“Œ Dungeon System
**ëª¨ë“ˆí˜• í™•ì¥ êµ¬ì¡°ì˜ ìœ ì—°í•œ ë˜ì „ UML**ğŸ¯
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UML_D1.png" width="650"/> </p>


## ğŸ¯ ì„¤ê³„ ëª©ì 
ì´ˆê¸°ì—ëŠ” ë‹¨ìˆœíˆ ëª¨ë“  ì  ì²˜ì¹˜ ì‹œ í´ë¦¬ì–´ë˜ëŠ” êµ¬ì¡°ë§Œ êµ¬í˜„í•˜ë ¤ í–ˆìœ¼ë‚˜, ë˜ì „ë³„ë¡œ ê³ ìœ í•œ ëª©í‘œì™€ ê·œì¹™ì„ ì œê³µí•˜ë©´ ê²Œì„ í”Œë ˆì´ì˜ ê¹Šì´ì™€ ë‹¤ì–‘ì„±ì´ í¬ê²Œ í–¥ìƒëœë‹¤ê³  íŒë‹¨í•˜ì—¬ í˜„ì¬ì˜ ëª¨ë“ˆí˜•Â·í™•ì¥í˜• êµ¬ì¡°ë¡œ ë°œì „ì‹œì¼°ìŠµë‹ˆë‹¤.  

ì„¤ê³„ ê³¼ì •ì—ì„œëŠ” ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ íŠ¹íˆ ì¤‘ì ì ìœ¼ë¡œ ê³ ë ¤í–ˆìŠµë‹ˆë‹¤.  

- **ìœ ì§€ë³´ìˆ˜ì„±**: ë˜ì „ë³„ ë¡œì§ ë¶„ë¦¬ ë° ë…ë¦½ ê´€ë¦¬  
- **í™•ì¥ì„±**: ë°ì´í„°ë§Œ êµì²´í•´ ë‹¤ì–‘í•œ ë˜ì „ ìœ í˜• ì¶”ê°€ ê°€ëŠ¥  

---

## ğŸ¯ Dungeon êµ¬ì„± ìš”ì†Œ 
ì•„ë˜ êµ¬ì„±ë“¤ì€ ë˜ì „ ì‹œìŠ¤í…œì˜ í•µì‹¬ ë°ì´í„°ë¥¼ ê°„ê²°í•˜ê²Œ í‘œí˜„í•œ êµ¬ì¡°ì…ë‹ˆë‹¤.  

## Title
- ë˜ì „ì˜ ì´ë¦„, ìœ í˜•, ì„¤ëª… ë“±  
- ë˜ì „ì„ ì‹ë³„í•˜ê³  UI ë° ì‹œìŠ¤í…œì—ì„œ í™œìš©ë˜ëŠ” ê¸°ë³¸ ì •ë³´  
- **( Normal, Rush, Protect, Rescuer, Target )**
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Title.png" width="650"/> </p>

  
## Category
- ì‚¬ìš©í•˜ëŠ” Controller ì„¤ì •.
```csharp
[CreateAssetMenu(menuName ="Map/Dungeon Category/Normal ", fileName ="NormalDungeonCategory")]
public class NormalDungeonCategory : BaseDungeonCateogry
{
    public override PlayerStateController InitControllerSetting(BaseDungeonTitle title)
    {
        PlayerStateController originController = title.OriginController;
        originController.allowStates.Clear();
        originController.allowStates.Add(originController.GetState<MoveState>());
        originController.allowStates.Add(originController.GetState<AttackState>());
        originController.allowStates.Add(originController.GetState<RollState>());
        originController.allowStates.Add(originController.GetState<SkillState>());
        originController.allowStates.Add(originController.GetState<DamagedState>());
        originController.allowStates.Add(originController.GetState<CounterAttackState>());
        originController.allowStates.Add(originController.GetState<DeadState>());
        originController.allowStates.Add(originController.GetState<DashState>());
        return originController;
    }
}
```
- Normal Categoryì—ì„œëŠ” í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ Stateë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.

## Condition
- ë˜ì „ì— ì…ì¥í•˜ê¸° ìœ„í•œ ì¡°ê±´ì„ ëª…ì‹œ  
  - í”Œë ˆì´ì–´ ë ˆë²¨  
  - í•„ìš” ì•„ì´í…œ  
  - íŠ¹ì • ìŠ¤í…Œì´ì§€ ì„ í–‰ ì—¬ë¶€  

## Function
- ë˜ì „ ì§„í–‰ ì „ì²´ë¥¼ ë‹´ë‹¹í•˜ëŠ” í•µì‹¬ í”„ë¡œì„¸ìŠ¤  
  - ë¼ìš´ë“œ ì‹œì‘  
  - ëª¬ìŠ¤í„°/ë³´ìŠ¤ ìŠ¤í°  
  - í´ë¦¬ì–´ ì¡°ê±´ ì²´í¬  
  - ì¢…ë£Œ ë° ë³´ìƒ ì²˜ë¦¬  

```csharp
[CreateAssetMenu(menuName = "Map/Dungeon Function/Normal Function ", fileName = "NormalFunction")]
public class NormalDungeonFunction : BaseDungeonFunction<NormalDungeonTitle>
{
    public override void ExcuteProcess(NormalDungeonTitle title)
    {
        SoundManager.Instance.PlayBGM_CrossFade(title.BaseBGM, 4f);
        title.SpawnData.dungeon = title.dungeonCoroutine;
        title.DungeonMapData.ExcuteTeleportMap();

        title.SpawnData.onExcuteBoss += () => { SoundManager.Instance.PlayBGM_CrossFade(title.BossBGM, 3f); };
        ScenesManager.Instance.OnExcuteAfterLoading = () => title.DungeonMapData.ExcuteTeleportController(title.ExcuteController, title.DungeonSpawnPosition);
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.SettingSpawnPositionList(title.DungeonSpawnPosition);
        ScenesManager.Instance.OnExcuteAfterLoading += () => GameManager.Instance.Cam.SetTarget(title.ExcuteController.gameObject);
        ScenesManager.Instance.OnExcuteAfterLoading += () => GameManager.Instance.Cam.ResetRotation();
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.StartWave();
        ScenesManager.Instance.OnExcuteAfterLoading += () => title.SpawnData.CreateExistBarrier();
        ScenesManager.Instance.OnExcuteAfterLoading += () => CommonUIManager.Instance.ExcuteGlobalNotifer(title.InitGlobalNotifier);

        title.SpawnData.onCompleteDungeon += () => QuestManager.Instance.ReceiveReport(QuestCategoryDefines.COMPLETE_DUNGEON, title.TaskTarget, 1);
        GameManager.Instance.Player.playerStats.OnDead_ += () => title?.SpawnData?.ExcuteFailProcess();
    }
}

```

## Reward
- í´ë¦¬ì–´ ë³´ìƒ ì •ë³´  
  - ê²½í—˜ì¹˜
  - ëª…ì„±ì¹˜
  - ìŠ¤í‚¬í¬ì¸íŠ¸
  - ì•„ì´í…œ  
  - ê³¨ë“œ  
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/R1.png" width="700" style="display:inline-block;"/>
  
## MapData
- ë˜ì „ì— ì‚¬ìš©ë˜ëŠ” ë˜ì „ Scene indexì™€ ìœ„ì¹˜, íšŒì „ ë“±ì˜ ë§µ ì •ë³´.

## SpawnPosition
- ë˜ì „ ë‚´ ìœ„ì¹˜ ì •ë³´ êµ¬ì„± ìš”ì†Œ  
  - í”Œë ˆì´ì–´ ì‹œì‘ ìœ„ì¹˜  
  - Enemy/Boss ìŠ¤í° ì§€ì   
  - íŠ¸ë¦¬ê±° ì´ë²¤íŠ¸ ìœ„ì¹˜  

  <p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜1.png" width="700" style="display:inline-block;"/>
-OnValidate() í•©ìˆ˜ë¡œ ë°‘ì—ìˆëŠ” Map Position Prefabì˜ ì •ë³´ë¥¼ ìë™ ì„¸íŒ…í•©ë‹ˆë‹¤.

<div align="center">
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜2.png" width="300" style="display:inline-block;"/>
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/í™”ë©´ ìº¡ì²˜3.png" width="300" style="display:inline-block;"/>
</div>
- OnDrawGizmos() í•¨ìˆ˜ë¡œ Root Transformì˜ child Transformì˜ ìœ„ì¹˜ë“¤ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œí•˜ë©° positions ë¦¬ìŠ¤íŠ¸ì— ìë™ ì¶”ê°€í•©ë‹ˆë‹¤.

## SpawnData 
- ì „íˆ¬ êµ¬ì„±ì— í•„ìš”í•œ ëª¨ë“  ìŠ¤í° ë° ë¼ìš´ë“œ ë°ì´í„°  
  - Enemy/Boss ìŠ¤í° ë¦¬ìŠ¤íŠ¸
  - Playable AI ë¦¬ìŠ¤íŠ¸
  - ì´ë™ ë¶ˆê°€ ë²½ ì •ë³´
  - ì›¨ì´ë¸Œ/ë¼ìš´ë“œ êµ¬ì„±   
- **( Normal, Rush, Protect, Rescuer, Target, TimeAttackRush )**
<p align="center"> <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/SpawnD1.png" width="650"/> </p>



## âš¡ Dash System
<p align="center">  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Dash.gif" width="400" style="display:inline-block;"/>
 
- ê³ ì† íƒ€ê²© ê¸°ë°˜ì˜ ì§€í˜•Â·ì  ê°ì§€í˜• ëŒ€ì‹œ ì‹œìŠ¤í…œ 

ëŒ€ì‹œ ì‹œìŠ¤í…œì€ ë‹¨ìˆœí•œ ëŒì§„ì´ ì•„ë‹ˆë¼ ì§€í˜•, ì , ì¥ì• ë¬¼, ì¹´ë©”ë¼, ì¿¨íƒ€ì„ UIë¡œ êµ¬ì„±ëœ ì „íˆ¬ ì‹œìŠ¤í…œìœ¼ë¡œ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

ì•„ë˜ ë‘ ê°€ì§€ ëª©í‘œë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ êµ¬í˜„ë˜ì—ˆìŠµë‹ˆë‹¤.
- **ì •í™•ì„± : ì•ˆì „í•˜ê²Œ ì´ë™ ê°€ëŠ¥í•œ ì§€ì ë§Œ ê³„ì‚°í•˜ì—¬ ì˜¤ë™ì‘ì„ ìµœì†Œí™”**
- **ì „ìˆ ì„± : ì Â·ì§€ë©´Â·ì¥ì• ë¬¼ íŒì •ì„ ì¡°í•©í•´ ì „ëµì ìœ¼ë¡œ ëŒ€ì‹œë¥¼ í™œìš© ê°€ëŠ¥**

## â­ Dash ì„¤ê³„ í•µì‹¬ ìš”ì†Œ
<div align="center">
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/G1.gif" width="450" style="display:inline-block;"/>
  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/G2.gif" width="450" style="display:inline-block;"/>
</div>

- ëŒ€ì‹œëŠ” ì•„ë˜ì™€ ê°™ì€ êµ¬ì¡°ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.

## Target Detect
- ëŒ€ìƒ ìœ„ì¹˜ ê³„ì‚°
  - BaseController ì—¬ë¶€ì— ë”°ë¼ í”¼ê²© ì¤‘ì‹¬ì  ë˜ëŠ” Transform ìœ„ì¹˜ë¥¼ íƒ€ê¹ƒ ì¢Œí‘œë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ì§€ë©´ ê²€ì¶œ ì‹œ ëŒ€ì‹œ ë¶ˆê°€
  - CheckDetectGround(targetDir, distance) ì—ì„œ ì§€ë©´ì´ ê°ì§€ë˜ë©´ í•´ë‹¹ ìœ„ì¹˜ëŠ” ëŒ€ì‹œ ëŒ€ìƒì—ì„œ ì œì™¸ë©ë‹ˆë‹¤.
- ì¥ì• ë¬¼ ê²€ì¶œ ì‹œ ëŒ€ì‹œ ë¶ˆê°€
  - CheckDetectObstacle(targetDir, distance) ê²°ê³¼ ì¥ì• ë¬¼ì´ ì°¨ë‹¨í•˜ê³  ìˆìœ¼ë©´ ëŒ€ì‹œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
- ê·¼ê±°ë¦¬ ëŒ€ìƒ ì •ë°€ ì²´í¬
  - íƒ€ê¹ƒì´ targetingAllowDistance ì´ë‚´ë¼ë©´, ë” ì¢ì€ ì¤‘ì•™ ìŠ¤í¬ë¦° ì˜ì—­(targetingLimitScreenPoint) ì•ˆì— ìˆì„ ë•Œë§Œ ëŒ€ì‹œë¥¼ í—ˆìš©í•©ë‹ˆë‹¤.
- ì¼ë°˜ íƒ€ê¹ƒíŒ… ì˜ì—­ ì²´í¬
  - ê·¼ê±°ë¦¬ ì¡°ê±´ì„ ì¶©ì¡±í•˜ì§€ ëª»í•˜ë”ë¼ë„, ë„“ì€ ê¸°ì¤€ ìŠ¤í¬ë¦° ì˜ì—­(limitDistance) ì•ˆì— ìœ„ì¹˜í•˜ë©´ ëŒ€ì‹œ ê°€ëŠ¥ ëŒ€ìƒìœ¼ë¡œ ì¸ì •í•©ë‹ˆë‹¤.
- ë‘ ì¡°ê±´ ëª¨ë‘ ë²—ì–´ë‚˜ë©´ ëŒ€ì‹œ ë¶ˆê°€
  - ìŠ¤í¬ë¦° ê¸°ì¤€ì ì„ ë²—ì–´ë‚˜ê±°ë‚˜ ê±°ë¦¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•  ê²½ìš° ëŒ€ì‹œëŠ” í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
```csharp
  private bool CheckCanDashTarget(Transform targetTr)
    {
        BaseController targetCon = targetTr.GetComponent<BaseController>();
        Vector3 targetPos = targetCon != null ? targetCon.damagedPosition.position : targetTr.position;
        Vector2 point = cam.MainCam.WorldToScreenPoint(targetPos);
        targetDir = (targetPos - centerPosition).normalized;
        float distance = (targetPos - (controller.transform.position + (Vector3)centerOffset)).magnitude;

        gizmoObstacleDir = targetDir;
        gizmoObstacleDistance = distance;

        //ë•…ì¼ê²½ìš°
        if (CheckDetectGround(targetDir, distance))
        {
            return false;
        }

        ///íƒ€ê²Ÿ ìœ„ì¹˜ì— ë ˆì´ì–´ ì´ì„œ ì¥ì• ë¬¼ ìˆë‚˜ íŒë‹¨.
        if (CheckDetectObstacle(targetDir, distance))
        {
            return false;
        }

        //íƒ€ê²ŸíŒ…ì¼ ê²½ìš° 
        if (distance <= targetingAllowDistance)
        {
            if (centerScreenPoint.x + targetingLimitScreenPoint.x >= point.x && centerScreenPoint.x - targetingLimitScreenPoint.x <= point.x &&
            centerScreenPoint.y + targetingLimitScreenPoint.y >= point.y && centerScreenPoint.y - targetingLimitScreenPoint.y <= point.y)
                return true;
        }

        if (centerScreenPoint.x + limitDistance.x >= point.x && centerScreenPoint.x - limitDistance.x <= point.x &&
            centerScreenPoint.y + limitDistance.y >= point.y && centerScreenPoint.y - limitDistance.y <= point.y)
        {
            return true;
        }

        return false;
    }

```

## Ground Check
- ëŒ€ì‹œ ê°€ëŠ¥í•œ ì§€ì ì„ ì°¾ê¸° ìœ„í•´ ëª©í‘œì ê¹Œì§€ì˜ ìˆ˜í‰ ì´ë™ ê±°ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¼ì • ê°„ê²©ìœ¼ë¡œ ì§€ë©´ì„ ìƒ˜í”Œë§í•©ë‹ˆë‹¤.
- ì‘ë™ ë°©ì‹
  - í”Œë ˆì´ì–´ â†’ íƒ€ê¹ƒ ë°©í–¥ìœ¼ë¡œ ì¼ì • Intervalë§Œí¼ ì „ì§„
  - ê° ì‹œì ì—ì„œ ì•„ë˜ë¡œ SphereCast
  - ì ì´ ìˆëŠ” ìœ„ì¹˜ë©´ Skip
  - ìµœì´ˆë¡œ ì•ˆì „í•œ ì§€ë©´ì„ ì°¾ìœ¼ë©´ ê·¸ ìœ„ì¹˜ë¡œ ì´ë™ í™•ì •

ğŸ”‘ í•µì‹¬ ì½”ë“œ
```csharp
private bool CheckCanDashGround()
{
    sumInterval = 0f;
    targetDirFromDashPos = (dashTargetTr.position - tmpDashPosition);
    groundDistance = targetDirFromDashPos.magnitude;
    groundSumCount = (int)((groundDistance - minDetectTargetDistance) / groundDetectInterval);
    currentTargetHeight = (dashTargetTr.position - controller.transform.position).y;

    if (currentTargetHeight < minDetectHeight || currentTargetHeight > maxDetectHeight)
        return false;

    targetDirFromDashPos.y = 0f;
    targetDirFromDashPos.Normalize();

    for (int i = 0; i < groundSumCount; i++)
    {
        startPos = tmpDashPosition + targetDirFromDashPos * sumInterval + Vector3.up * groundStartYOffset;
        sumInterval += groundDetectInterval;

        if (DetectEnemy(startPos))
            continue;

        if (Physics.SphereCast(startPos, groundDetectRadius, -Vector3.up,out groundCheckRayHit, groundYRange, groundLayer))
        {
            canDashPosition = groundCheckRayHit.point;
            return true;
        }
        else
            canDashPosition = Vector3.zero;
    }
    return false;
}
```

## Enemy Detection
- ëŒ€ì‹œ ê²½ë¡œì— ì ì´ ìˆëŠ”ì§€ ê²€ì‚¬í•´ ì¶©ëŒ ê°ì§€ ì‹œ Skip ë˜ëŠ” Hit ì²˜ë¦¬í•©ë‹ˆë‹¤.

ğŸ”‘ í•µì‹¬ ì½”ë“œ
```csharp
private bool DetectEnemy(Vector3 startPosition)
{
    RaycastHit groundHit;

    // 1) ì§€ë©´ì´ ì—†ëŠ” ê²½ìš° - ì•ˆì „
    if (!Physics.Raycast(startPosition, -Vector3.up, out groundHit, groundYRange, groundLayer))
        return true;

    // 2) ì§€ë©´ê¹Œì§€ SphereCast ì‹œ ì  ê°ì§€
    if (Physics.SphereCast(startPosition, groundDetectRadius, -Vector3.up,
        out groundCheckRayHit, groundHit.point.y, enemyLayer))
    {
        drawEnemyHitPoints.Add(groundCheckRayHit.point);
        return true;
    }

    // 3) ì‹œì‘ ì§€ì ì— ì ì´ ìˆëŠ”ì§€ ê²€ì‚¬
    if (Physics.OverlapSphereNonAlloc(startPosition, groundDetectRadius,
        groundEnemyColls, enemyLayer) > 0)
    {
        drawEnemyHitPoints.Add(startPosition);
        return true;
    }

    return false;
}
```

## Obstacle Check
<p align="center">  <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/Ground.gif" width="400" style="display:inline-block;"/>
 
- ëŒ€ì‹œ ê²½ë¡œì— ì¥ì• ë¬¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ ì‚¬ì „ ê²€ì¶œí•©ë‹ˆë‹¤.
  - OverlapSphereNonAlloc ê¸°ë°˜ ì¶©ëŒ ì˜ˆì¸¡ ë° ìµœì í™”
- ì¥ì• ë¬¼ê³¼ ì¶©ëŒí•˜ë©´ Target ìë™ ë³€ê²½ ë˜ëŠ” ëŒ€ì‹œ ì·¨ì†Œ

## Dash Movement + Camera + UI
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/UI1.gif" width="400" style="display:inline-block;"/>

- íƒ€ê¹ƒ UIë¡œ í˜„ì¬ ì„ íƒëœ ëŒ€ìƒ ì‹œê°í™” 
- ëŒ€ì‹œ ì´ë™ì´ í—ˆìš©ë˜ë©´ ë‹¤ìŒ ì²˜ë¦¬ê°€ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.
  - ì¹´ë©”ë¼ FOV ë³€í™”
  - ì›ê±°ë¦¬/ê·¼ê±°ë¦¬ ëŒ€ì‹œë³„ SmoothSpeed ìë™ ì¡°ì ˆ
  - ì„±ê³µ ì¹´ìš´íŠ¸ UI ì—…ë°ì´íŠ¸
  - ëŒ€ì‹œ ìŠ¤íƒ ê¸°ë°˜ ì¿¨íƒ€ì„ íšŒë³µ

```csharp
 private IEnumerator DashMoveProcess_Co()
    {
        if (dashTargetTr == null)
            yield break;
        float endTime = dashClip.EndTime;

        if (CanTeleportToTarget(dashTargetTr))
        {
            StartCoroutine(DashCameraProcess_Co(false));
            yield return new WaitForSeconds(farDelayFOVMoveTime);
            controller.RotateToTarget(dashTargetTr.position);
            controller.myAnimator.CrossFade(dashClip.AnimationName, 0.1f);
            controller.TranslatePosition(canDashPosition);
            controller.StartCoroutine(DashDamageProcess_Co());
        }
        else
        {
            StartCoroutine(DashCameraProcess_Co(true));
            yield return new WaitForSeconds(nearDelayFOVMoveTime);
            controller.RotateToTarget(dashTargetTr.position);
            controller.myAnimator.CrossFade(dashClip.AnimationName, 0.1f);
            controller.StartCoroutine(DashDamageProcess_Co());
        }

        yield return new WaitForSeconds(dashClip.EndTime);
        doneDashState = true;
        dashTargetTr = null;
    }
 

```


# â³ íŠ¸ëŸ¬ë¸” ìŠˆíŒ…
## ğŸ¨ ë©”í…Œë¦¬ì–¼ ìµœì í™” ê³¼ì •
- NPCë‚˜ ëª¬ìŠ¤í„°ë¥¼ ìƒì„±í•  ë•Œ, ìºë¦­í„°ë³„ë¡œ ì§€ì •ëœ ìƒ‰ìƒì„ ì ìš©í•˜ê¸° ìœ„í•´ ë©”í…Œë¦¬ì–¼ ì»¬ëŸ¬ ê°’ì„ ë³€ê²½í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.
- ì¦‰, ìŠ¤í°ëœ ìºë¦­í„°ë§ˆë‹¤ ê³ ìœ í•œ ìƒ‰ìƒì„ ì„¤ì •í•˜ëŠ” ê³¼ì •ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ë©”í…Œë¦¬ì–¼ì„ ìˆ˜ì •í•˜ëŠ” ë¡œì§ì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤.

## âš  ë¬¸ì œ ë°œìƒ
- ë©”í…Œë¦¬ì–¼ì˜ ìƒ‰ìƒì„ ë³€ê²½í•˜ëŠ” ê³¼ì •ì—ì„œ ê¸°ì¡´ ë©”í…Œë¦¬ì–¼ì„ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, Unityê°€ ë‚´ë¶€ì ìœ¼ë¡œ ìƒˆë¡œìš´ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ë³€ê²½ì„ ì ìš©í•˜ê³  ìˆë‹¤ëŠ” ì‚¬ì‹¤ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.

ì¦‰, **ê³µìœ  ë©”í…Œë¦¬ì–¼(Shared Material)** ì„ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, Rendererë§ˆë‹¤ **ê³ ìœ í•œ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤(Material Instance)** ë¥¼ ìƒˆë¡œ ìƒì„±í•´ ì ìš©í•˜ëŠ” êµ¬ì¡°ì˜€ìŠµë‹ˆë‹¤.

- ì´ë¡œ ì¸í•´ NPCë‚˜ ëª¬ìŠ¤í„°ê°€ ë§ì•„ì§ˆìˆ˜ë¡ ê³ ìœ  ì¸ìŠ¤í„´ìŠ¤ê°€ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ëŠ˜ì–´ë‚¬ê³ , ê·¸ë§Œí¼ ë“œë¡œìš°ì½œ ì¦ê°€ â†’ ë°°ì¹­ì´ ê¹¨ì§ â†’ í¼í¬ë¨¼ìŠ¤ ì €í•˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.

## ğŸ” ì›ì¸ ë¶„ì„
- Unityì˜ ë©”í…Œë¦¬ì–¼ êµ¬ì¡°ìƒ renderer.materialì„ ìˆ˜ì •í•˜ë©´ ê¸°ì¡´ ë©”í…Œë¦¬ì–¼ì€ ê³µìœ ëœ ìƒíƒœ

ìˆ˜ì • ìˆœê°„ Rendererë§ˆë‹¤ ê³ ìœ í•œ ì¸ìŠ¤í„´ìŠ¤(Material Instance)ë¥¼ ìƒì„±
í•˜ê²Œ ë©ë‹ˆë‹¤.

ì¦‰, ìƒ‰ìƒ í•˜ë‚˜ë§Œ ë°”ë€Œì–´ë„ ì „ë¶€ ë‹¤ë¥¸ ë©”í…Œë¦¬ì–¼ë¡œ ì¸ì‹ë˜ê¸° ë•Œë¬¸ì—
Static/Dynamic Batchingì´ ì ìš©ë˜ì§€ ì•Šê³  Draw Callì´ ë¶ˆí•„ìš”í•˜ê²Œ í™•ëŒ€ë˜ëŠ” ê²ƒì´ ì›ì¸ì´ì—ˆìŠµë‹ˆë‹¤.

## âœ… í•´ê²° ë°©ë²• 

- ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **Material Property Block** ë°©ì‹ì„ ì ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.
- Material Property BlockëŠ” ê¸°ì¡´ ê³µìœ  ë©”í…Œë¦¬ì–¼ì„ ìœ ì§€í•œ ì±„, Rendererë³„ ìƒ‰ìƒÂ·íŒŒë¼ë¯¸í„°ë§Œ ê°œë³„ì ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

ì´ë¡œì¸í•´ ë©”í…Œë¦¬ì–¼ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•Šê³ , ë“œë¡œìš°ì½œì„ ì¦ê°€ì‹œí‚¤ì§€ ì•Šìœ¼ë©°, ì»¤ìŠ¤í„°ë§ˆì´ì§• ìƒ‰ìƒ ì ìš©ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

```csharp
 public void SetMaterialsColor(Renderer renderer)
    {
        MaterialPropertyBlock propertyBlock = new MaterialPropertyBlock();

        propertyBlock.SetColor("_Color_Primary", Color_Primary);
        propertyBlock.SetColor("_Color_Secondary", Color_Secondary);
        propertyBlock.SetColor("_Color_Leather_Primary", Color_Leather_Primary);
        propertyBlock.SetColor("_Color_Metal_Primary", Color_Metal_Primary);
        propertyBlock.SetColor("_Color_Leather_Secondary", Color_Leather_Secondary);
        propertyBlock.SetColor("_Color_Metal_Dark", Color_Metal_Dark);
        propertyBlock.SetColor("_Color_Metal_Secondary", Color_MertalSecondary);
        propertyBlock.SetColor("_Color_Hair", Color_Hair);
        propertyBlock.SetColor("_Color_Skin", Color_Skin);
        propertyBlock.SetColor("_Color_Stubble", Color_Stubble);
        propertyBlock.SetColor("_Color_Scar", Color_Scar);
        propertyBlock.SetColor("_Color_BodyArt", Color_BodyArt);
        propertyBlock.SetColor("_Color_Eyes", Color_Eyes);

        renderer.SetPropertyBlock(propertyBlock);
    }
```



## ğŸ¨Layout group ì‚¬ìš© ì¤‘ ë°œìƒí•œ ì„±ëŠ¥ ë¬¸ì œ  
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/L1.png" width="500" style="display:inline-block;"/>

- ì´ˆê¸°ì—ëŠ” Inventory, ìƒì  UI, Reward UI ë“± ë‹¤ìˆ˜ì˜ UI ìš”ì†Œê°€ í‘œì‹œë˜ëŠ” í™”ë©´ì— Unityê°€ ê¸°ë³¸ ì œê³µí•˜ëŠ” Layout Groupì„ ì‚¬ìš©í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.
  ë ˆì´ì•„ì›ƒ ì •ë ¬ì´ ìë™ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ UI êµ¬ì„±ì€ í¸ë¦¬í–ˆì§€ë§Œ, ì‹¤ì œ í”Œë ˆì´ í™˜ê²½ì—ì„œëŠ” ì˜ˆìƒì¹˜ ëª»í•œ ì„±ëŠ¥ ì €í•˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. 


## âš  ë¬¸ì œ ë°œê²¬

- UI ìš”ì†Œê°€ ë§ì•„ì§ˆìˆ˜ë¡ í™”ë©´ ì „í™˜ ë° ìŠ¤í¬ë¡¤ ìƒí™©ì—ì„œ í”„ë ˆì„ ì €í•˜ê°€ ëˆˆì— ë„ê²Œ ì¦ê°€
- Inventoryë‚˜ ìƒì ì²˜ëŸ¼ ìì‹ UIê°€ ë§ì€ íŒ¨ë„ì—ì„œ Canvas Rebuildê°€ ë°˜ë³µì ìœ¼ë¡œ ë°œìƒ
- ì¦‰, ë¶ˆí•„ìš”í•œ ì‘ì—…ì´ ë°œìƒ.

  
## âœ… í•´ê²° ë°©ë²•
- Unity ê¸°ë³¸ Layout Group ì‚¬ìš©ì„ ì¤‘ë‹¨í•˜ê³ , ë ˆì´ì•„ì›ƒì„ í•„ìš”í•  ë•Œë§Œ **ë‹¨ì¼ í˜¸ì¶œ**ë¡œ ê°±ì‹ í•˜ëŠ” êµ¬ì¡°ë¡œ ì¬ì„¤ê³„í•˜ì˜€ìŠµë‹ˆë‹¤.
- UI ë³€ë™ ì—¬ë¶€ì— ë”°ë¼ ì½˜í…ì¸  í¬ê¸°ë¥¼ ìë™ ì¬ì¡°ì •í•  ìˆ˜ ìˆë„ë¡ **Content Size Filter** ê¸°ëŠ¥ì„ ì„ íƒì  ì˜µì…˜ìœ¼ë¡œ ì œê³µí•´ ìœ ì—°í•˜ê²Œ í™œìš©í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.

BaseLayoutGroupì„ ë¶€ëª¨ë¡œ, Grid / Horizontal / Verticalì˜ ê¸°ëŠ¥ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.


**1) AnchorSetting()**
<p align="center">   <img src="https://raw.githubusercontent.com/seokyoungryu/UnityPortfolio-ChronoBreach/main/UI/L2_1.png" width="500" style="display:inline-block;"/>
- ìš°ì„  AnchorSettings() í•¨ìˆ˜ë¥¼ í†µí•´ ì •ë ¬í•  RectTrasnformë“¤ì˜ Anchorìœ„ì¹˜ë¥¼ ì™¼ìª½ ìƒë‹¨ìœ¼ë¡œ ì„¸íŒ…í•©ë‹ˆë‹¤.

```csharp
 protected void AnchorSettings()
    {
        if (uiRect == null)
            uiRect = GetComponent<RectTransform>();
        else if (uiRect != null)
            uiRect.pivot = new Vector2(0, 1);

        foreach (RectTransform rect in childRects)
        {
            rect.anchorMin = new Vector2(0, 1);
            rect.anchorMax = new Vector2(0, 1);
            rect.pivot = new Vector2(0, 1);
        }
    }
```


**1) SortLayout() â€” UI ë°°ì¹˜ ê³„ì‚°ì˜ í•µì‹¬ ë©”ì„œë“œ**
- ì•„ë˜ ë©”ì„œë“œëŠ” UI ìš”ì†Œë¥¼ Row ë˜ëŠ” Column ê¸°ì¤€ìœ¼ë¡œ ë°°ì¹˜í•˜ë©°, íŒ¨ë”©Â·ê°„ê²©Â·ìŠ¬ë¡¯ í¬ê¸° ê³„ì‚° í›„ Anchor ê¸°ì¤€ ìœ„ì¹˜ë¥¼ ì§ì ‘ ì‚°ì¶œí•©ë‹ˆë‹¤.

```csharp
 protected override void SortLayout(List<RectTransform> rectList)
    {
        if (rectList.Count <= 0) 
        {
            uiRect.sizeDelta = new Vector2(0,0);
            return;
        }
        float paddingLR = paddings.left > 0 ? paddings.left : -paddings.right;
        float rectWidth = 0f;
        float rectHeight = 0f + paddings.top;
        int index = 0;

        foreach (RectTransform rect in rectList)
        {
            float paddingBottom = paddings.bottom > 0 ? paddings.bottom : 0;

            if (IsRow())
                RowCalculate(index, ref rectWidth, ref rectHeight, rect);
            else
                ColumeCalculate(index, ref rectWidth, ref rectHeight, rect);

            rect.anchoredPosition = new Vector2(rectWidth + paddingLR, -rectHeight + paddingBottom);
            index++;
        }

        ContentSizeFilter(index, rectWidth, rectHeight);
    }

```

**2) ContentSizeFilter() â€” UI ì½˜í…ì¸  í¬ê¸° ìë™ ì¡°ì • ê¸°ëŠ¥**
- UI í•­ëª©ì´ ë™ì ìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ê²½ìš°, ì „ì²´ ìŠ¬ë¡¯ ì˜ì—­ì´ UI ë‚´ë¶€ì— ìì—°ìŠ¤ëŸ½ê²Œ í™•ì¥ë˜ë„ë¡ Row ë˜ëŠ” Column ê¸°ì¤€ìœ¼ë¡œ RectTransformì˜ sizeDeltaë¥¼ ìë™ ì‚°ì¶œí•©ë‹ˆë‹¤.

```csharp
   private void ContentSizeFilter(int index, float rectWidth, float rectHeight)
    {
        if (useContextSizeFilter && uiRect != null)
        {
            if (IsRow())
            {
                float uiRectWidth = childRects[0].rect.width * RoundToInt(index, row);
                float uiRectHeight = childRects[0].rect.height * (row > index ? index : row);
                uiRect.sizeDelta = new Vector2(rectWidth + childRects[0].rect.width, uiRectHeight);
            }
            else
            {
                float uirectWidth = childRects[0].rect.width * (colume > index ? index : colume);
                float uirectHeight = childRects[0].rect.height * RoundToInt(index, colume);
                uiRect.sizeDelta = new Vector2(uirectWidth, rectHeight + childRects[0].rect.height);
            }
        }
    }

```


---
